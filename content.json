{"meta":{"title":"却又像风","subtitle":null,"description":null,"author":"却又像风","url":"https://Zhangbingwu.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-07-18T07:03:31.000Z","updated":"2019-07-18T07:04:01.872Z","comments":true,"path":"tags/index.html","permalink":"https://Zhangbingwu.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-18T07:04:21.000Z","updated":"2019-07-18T07:05:53.842Z","comments":true,"path":"categories/index.html","permalink":"https://Zhangbingwu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MyBatis分页插件","slug":"MyBatis分页插件","date":"2019-08-20T16:00:00.000Z","updated":"2019-08-21T08:24:51.200Z","comments":true,"path":"2019/08/21/MyBatis分页插件/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/21/MyBatis分页插件/","excerpt":"","text":"MyBatis分页插件 依赖 123456&lt;!--mybatis分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; mybatis.xml用于配置分页插件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--告诉分页插件数据库类型--&gt;&lt;!-- &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;--&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 注意： 要作为mybatis插件必须实现interceptor接口，而PageHelper实现的是Dialect，5.0后，PageInterceptor实现了interceptor。 所以应该是：interceptor=”com.github.pagehelper.PageInterceptor” 而不是：interceptor=”com.github.pagehelper.PageHelper” 分页代码1234567891011121314public EasyUIDataGrid show(int page, int rows) &#123; //设置分页条件，第几页？一页多少行？ PageHelper.startPage(page,rows); //查询全部 List&lt;TbItem&gt; list = tbItemMapper.selectByExample(new TbItemExample()); //分页代码 //将TbItem表查询全部后所有信息放入PageInfo中，PageInfo来计算出需要的数据，可以进入PageInfo查看。 PageInfo&lt;TbItem&gt; pi = new PageInfo&lt;&gt;(list); //将数据放入到EasyUIDataGrid中。 EasyUIDataGrid easyUIDataGrid = new EasyUIDataGrid(); easyUIDataGrid.setRows(pi.getList()); easyUIDataGrid.setTotal(pi.getTotal()); return easyUIDataGrid;&#125; 注意：mybatis分页插件，在进行分页时，是查询时就分页(limit)，所以需要将设置分页条件提前。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[]},{"title":"Redis","slug":"Redis","date":"2019-08-17T16:00:00.000Z","updated":"2019-08-18T03:58:30.947Z","comments":true,"path":"2019/08/18/Redis/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/18/Redis/","excerpt":"","text":"Redis简介 Redis 是一个基于key-value形式进行存储的内存型数据库。 数据存储方式为 key-value 数据存储在内存中. 优点:效率高.理论值:每秒 10K 数据读取. 定位:数据库软件. 作用:存储数据. Redis 是一个NoSQL 数据库 Not Only SQL 不仅仅是数据库 在应用程序开发时,不是必须使用关系型数据库,可以使用NoSQl替代关系型数据库的部分功能. NoSQL数据库在以下的这几种情况下比较适用： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求较高； 不需要高度的数据一致性； 对于给定key，比较容易映射复杂值的环境。 注意： 关系型数据库依然做为数据存储的主要软件. NoSQL 数据库当作缓存工具来使用.把某些使用频率较高的内容不仅仅存储到关系型数据库中还存储到 NoSQL 数据 考虑到:NoSQL 和关系型数据库数据同步的问题. Redis的持久化策略 当应用程序获取数据时，先去NoSQL(内存)中找，有的话直接返回数据，没有的话去关系型数据库中找(硬盘)，并把数据更新到NoSQL中。 问题：NoSQL中数据与关系型数据库一致性问题？ 1.rdb 默认的持久化策略. 每隔一定时间后把内存中数据持久化到 dump.rdb 文件中.缺点: 1.数据过于集中. 2.可能导致最后的数据没有持久化到 dump.rdb 中解决办法:使用命令:SAVE 或BGSAVE手动持久化. 2.aof 监听 Redis 的日志文件,监听如果发现执行了修改,删除,新增命令.立即根据这条命令把数据持久化.缺点: 效率降低. Redis常用命令 (命令手册)[http://doc.redisfans.com/] set , get ,del . setexSETEX key seconds value存放多少秒seconds如果key存在，SETEX将复写旧值。 setnxSETNX key value将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。 Redis 数据类型 String Hash List Set SortedSet 有序集合 Redis 几个常用概念 Redis 默认有 16384 solts(槽),每个槽可以存储多个 hash 值. Redis 默认不需要密码:redis.conf中 requirepass注释去掉,设置自己的密码 设置密码后需要通过 -h 主机 ip -p 端口 -a 密码./redis-cli -h 192.168.139.132 -p 6379 -a 密码 Jedis Jedis时Redis客户端工具jar 添加Maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt; 非集群Jedis jedis = new Jedis(“192.168.139.132”, 6379);jedis.set(“name”,zs);jedis.get(“name”);jedis.del(“name”); 集群cluster 12345678910111213@Testpublic void test() &#123; Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;(); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7001)); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7002)); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7003)); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7004)); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7005)); set.add(new HostAndPort(&quot;192.168.44.131&quot;,7006)); JedisCluster cluster = new JedisCluster(set); String result = cluster.get(&quot;abc&quot;); System.out.println(result);&#125; Redis 集群集群 多个业务单元协同工作组成的整体称为集群.每个业务单元都是相同的. 当集群中业务单元中超过或等于 1/2 个 down 掉时整个集群不可用. 建议使用奇数个,整体 down 机率小 一主一备模式 给每个业务单元创建一个备份业务单元. 原来的业务单元(master)后产生的叫做(slave)。当主业务单元down后，或者工作量巨大时，slave业务单元工作。 集群和伪集群 集群: 每个业务单元都安装到单独的服务器上 伪集群: 所有业务单元都安装到同一个服务器上,通过端口区分不同的业务单元. Junit 单元测试插件 目的：可以不编写main方法 要求： 方法必须是public void 方法没有返回值，没有参数 当前项目不要有Test类，否则@Test会引用自己的Test类。 Maven添加依赖 在需要测试的方法上添加@Test @Before 在@Test 之前执行 @After 在@Test 之后执行. 如果有多个@Test 每个@Test 前后都会执行@Before和@Afte","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://Zhangbingwu.github.io/tags/Redis/"},{"name":"Junit","slug":"Junit","permalink":"https://Zhangbingwu.github.io/tags/Junit/"}]},{"title":"Mybatis逆向工程","slug":"Mybatis逆向工程","date":"2019-08-16T16:00:00.000Z","updated":"2019-08-18T08:52:14.802Z","comments":true,"path":"2019/08/17/Mybatis逆向工程/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/17/Mybatis逆向工程/","excerpt":"","text":"Mybatis逆向工程 问题 由于下载的逆向工程mysql连接版本太低，换为8.0.16依赖。 找不到资源文件，加载不到xml文件，选择绝对路径加载。File configFile = new File(&quot;D:/IDEA全/easyui/mybatis/src/generatorConfig.xml&quot;); 运行完成没有效果，再次改为绝对路径生成pojo，mapper 123&lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;D:\\IDEA全\\easyui\\mybatis\\src\\main\\java&quot;&gt; jdbc连接驱动1.jdbc:mysql://localhost:3306/sorm?serverTimezone=CTT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;allowMultiQueries=true2.jdbc:mysql://localhost:3306/sorm?serverTimezone=GMT 具体步骤 添加Maven依赖 1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;!-- mybatis-generator自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置generatorConfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/sorm?serverTimezone=GMT&quot; userId=&quot;root&quot; password=&quot;670322387&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;pojo&quot; targetProject=&quot;D:\\IDEA全\\easyui\\mybatis\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;D:\\IDEA全\\easyui\\mybatis\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;mapper&quot; targetProject=&quot;D:\\IDEA全\\easyui\\mybatis\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;img&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建Generator类 12345678910111213141516171819202122232425262728293031import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class Generator &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; /**指向逆向工程配置文件*/ File configFile = new File(&quot;D:/IDEA全/easyui/mybatis/src/generatorConfig.xml&quot;); ConfigurationParser parser = new ConfigurationParser(warnings); Configuration config = parser.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; Generator generatorSqlmap = new Generator(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Mybatis逆向工程的使用 每一个pojo都有一个对应的Example，查询体。1.创建查询体2.是否需要条件 example.createCriteria() 创建条件3.example.createCriteria().andIdEqualTo(1)，相当于where id=14.example.createCriteria().andIdGreaterThan(1) 相当于 where id&gt;1 多个条件，流形式追加。 12345 //查询体 ImgExample example = new ImgExample(); example.createCriteria().andIdEqualTo(1).andPathEqualTo(&quot;&quot;);// example.createCriteria().andIdGreaterThan(1); List&lt;Img&gt; imgs = imgMapper.selectByExample(example);","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://Zhangbingwu.github.io/tags/Mybatis/"}]},{"title":"VSFTPD&Nginx","slug":"VSFTPD&Nginx","date":"2019-08-14T16:00:00.000Z","updated":"2019-08-21T08:27:24.121Z","comments":true,"path":"2019/08/15/VSFTPD&Nginx/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/15/VSFTPD&Nginx/","excerpt":"","text":"VSFTPD简介 Linux 的组件(一款软件),安装到 Linux 后通过 java 代码(FtpClient)实现文件上传. VSFTPD 基于 FTP 协议 为什么要使用 VSFTPD? 以前使用文件上传，tomcat会保存文件。 如果搭建集群，多个服务器运行一个项目，如何进行文件上传？ 如何进行文件下载？ 如何进行文件上传？搭建一个用于存储文件的服务器，利用vsftpd。 如何进行文件下载？解决办法使用 Nginx 进行反向代理. 注意： 如果希望在客户端直接访问图片服务器中的图片,由于VSFTPD 是基于 FTP 协议的,客户端浏览器是需要通过 http 协议访问图片。 客户端获取文件 可以使用格式在浏览器中访问到对应的图片(不推荐这样使用) 在谷歌浏览器中直接访问到 ftpuser 目录 在 IE 中访问的是 linux 的根目录ftp://用户名:密码@192.168.000.000 FtpClient 1.java 技术,使用 FtpClient可以通过java代码上传文件到 vsftpd服务器1234567891011121314public static void main(String[] args) throws IOException &#123; FTPClient ftp = new FTPClient(); //连接 ftp.connect(&quot;192.168.44.130&quot;,21); //登录 ftp.login(&quot;ftpuser&quot;,&quot;ftpuser&quot;); //设置文件类型 二进制类型 ftp.setFileType(FTPClient.BINARY_FILE_TYPE); InputStream is = new FileInputStream(&quot;d:/1.jpg&quot;); //存储时名称 ftp.storeFile(&quot;hh.jpg&quot;,is); //退出 ftp.logout(); &#125;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"VSFTPD&Nginx","slug":"VSFTPD-Nginx","permalink":"https://Zhangbingwu.github.io/tags/VSFTPD-Nginx/"}]},{"title":"Dubbo搭建问题","slug":"Dubbo搭建问题","date":"2019-08-12T16:00:00.000Z","updated":"2019-08-14T13:35:17.420Z","comments":true,"path":"2019/08/13/Dubbo搭建问题/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/13/Dubbo搭建问题/","excerpt":"","text":"consumer搭建遇到的问题 搭建完成后可以正常启动tomcat，但是访问Controller时报错，出现空指针问题，在调用provider方法时报空指针。 解决：百度后发现，这和springmvc配置文件有关，原本我是分两个xml文件配置mvc和dubbo的，发现原因可能是springmvc在扫描注解时，也就是扫描controller时就会去注入，而此时dubbo注解扫描还未开始，因此出现空指针。于是我将springmvc和dubbo合成一个，如下。 123456789101112&lt;!-- 注解驱动,注册HandlerMapping和HandlerAdapter --&gt;&lt;mvc:annotation-driven/&gt;&lt;!--给当前provider起名--&gt;&lt;dubbo:application name=&quot;dubbo-service&quot;/&gt;&lt;!--注册配置中心--&gt;&lt;dubbo:registry address=&quot;192.168.44.128:2181&quot; protocol=&quot;zookeeper&quot;/&gt;&lt;!--配置dubbo注解扫描,先进行dubbo注解再进行controller注解扫描，否则出现空指针--&gt;&lt;dubbo:annotation package=&quot;com.zbw.service.impl&quot;/&gt;&lt;!-- 扫描注解,只扫描controller包 --&gt;&lt;context:component-scan base-package=&quot;com.zbw.controller&quot;/&gt; 正常运行后，调用方法返回的字符串出现中文乱码。 尝试解决：使用插件发现编码格式未UTF-8，尝试用String转码，结果失败。 最终未解决。 8-14在进行正常dubbo框架web项目时，消费方远程调用服务方(数据访问层)方法显示jsp页面正常，没有中文乱码情况。","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://Zhangbingwu.github.io/tags/Dubbo/"}]},{"title":"Dubbo学习","slug":"Dubbo","date":"2019-08-12T16:00:00.000Z","updated":"2019-08-14T13:43:36.276Z","comments":true,"path":"2019/08/13/Dubbo/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/13/Dubbo/","excerpt":"","text":"SOA (Service Oriented Ambiguity) 面向服务架构 有一个专门提供服务的单元。 其他所有单元都调用这个服务。 使用SOA架构 不会出现多个项目能够直接访问数据库，保护了数据的安全。 开发时可以实现代码的复用。 实现SOA架构时,常用服务. Dubbo 做为服务. WebService 做为服务. Dubbox 做为服务. 服务方就是web项目,调用web项目的控制器. 使用HttpClient可以调用其他项目的控制器. RPC (Remote Procedure Call Protocol) 远程过程调用协议 解析：客户端在通过互联网调用远程服务器的功能时，不知道功能的具体实现，只知道它提供了什么功能。 优点：数据安全性。 Dubbo Dubbo:一个分布式、高性能、透明化的RPC服务框架 作用:提供服务自动注册、自动发现等高效服务治理方案. 角色 Provider :提供者,服务发布方,方法及其实现 Consumer:消费者, 调用服务方 Container:Dubbo容器.依赖于Spring容器. Registry: 注册中心.当Container启动时把所有可以提供的服务列表上Registry中进行注册. 作用:告诉Consumer提供了什么服务和服务方在哪里. Monitor:监听器 注意： 所有的角色都是可以在单独的服务器上.所以必须遵守特定的协议. 只有consumer在invoke provider方法时是同步的，其他步骤都是异步的。 运行原理 首先启动bubbo容器，加载provider。 加载完成后，向registry注册中心注册其服务列表，地址。 consumer启动后，去registry获取服务列表以及provider地址，进行订阅。 当provider有修改后，注册中心会把消息推送给consumer。1.使用了观察者设计模式(又叫发布/订阅设计模式) 根据获取到的provider地址，调用provider功能。1.consumer方使用了代理设计模式，创建了一个provider方类的一个代理对象，通过代理对象获取provider中真实功能，起到了保护provider的作用。 Consumer和Provider每隔1分钟向Monitor发送统计信息,统计信息包含,访问次数,频率等. 注册中心使用zookeeper 发布订阅功能.把zookeeper当作注册中心原因. 分布式/集群管理功能. Dubbo支持的协议 1.Dubbo Dubbo官方推荐的协议. 本质:使用NIO和线程池进行处理. 缺点:大文件传输时可能出现文件传输失败问题. 2.RMI JDK提供的协议,远程方法调用协议. 缺点:偶尔连接失败. 优点:JDK原生,不需要进行额外配置(导入jar) 3.Hession 优点:基于http协议,http请求支持. 缺点:需要额外导入jar,并在短连接时性能低 Maven打包插件Assembly对provider进行打包，让服务方可以在其他及其运行。 在provider项目(实现类项目)中pom.xml中配置assembly插件信息。 123456789101112131415161718&lt;!-- 指定项目的打包插件信息 --&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定打包描述文件的位置：相对项目根目录的路径 --&gt; &lt;!-- assembly打包的描述文件 --&gt; &lt;descriptor&gt;assembly/assembly.xml&lt;/descriptor&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在项目根目录下新建assembly文件夹 在assembly文件夹中新建assembly.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;assembly xmlns=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd&quot;&gt; &lt;!-- 该字符会添加到最终tar.gz包的名称后面，作为后缀 --&gt; &lt;id&gt;assembly&lt;/id&gt; &lt;!-- 指定打包的格式为tar.gz，该类型压缩包在linux中比较常见 --&gt; &lt;formats&gt; &lt;format&gt;tar.gz&lt;/format&gt; &lt;/formats&gt; &lt;!-- 在tar.gz压缩包中是否包含根文件夹，该根文件夹名称和tar.gz去掉id后缀一致 --&gt; &lt;includeBaseDirectory&gt;true&lt;/includeBaseDirectory&gt; &lt;fileSets&gt; &lt;!-- 将项目根路径下assembly/bin路径中的内容打包到压缩包中的根目录下的bin目录中 --&gt; &lt;fileSet&gt; &lt;!-- 相对项目根路径的相对路径 --&gt; &lt;directory&gt;assembly/bin&lt;/directory&gt; &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt; &lt;!-- 设置最终tar.gz中该文件夹下的权限，跟linux权限写法一致 --&gt; &lt;fileMode&gt;0755&lt;/fileMode&gt; &lt;/fileSet&gt; &lt;!-- 将项目根路径下assembly/conf路径中的内容打包到压缩包中的根目录下的conf目录中 --&gt; &lt;fileSet&gt; &lt;directory&gt;assembly/conf&lt;/directory&gt; &lt;outputDirectory&gt;conf&lt;/outputDirectory&gt; &lt;!-- 设置其linux权限 --&gt; &lt;fileMode&gt;0644&lt;/fileMode&gt; &lt;/fileSet&gt; &lt;/fileSets&gt; &lt;!-- 将所有依赖的jar包打包到压缩包中的根目录下的lib目录中 --&gt; &lt;!-- 此lib目录中包含自己开发的项目jar包以及demo_service.jar，还有第三方的jar包 --&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt;&lt;/assembly&gt; 解压下载的dubbo-monitor-simple-2.5.3-assembly.tar.gz压缩包,把解压后的bin和conf粘贴到项目下assembly文件夹中. 注意：清空conf/dubbo.properties中内容(zookeeper信息). 右键项目–&gt; maven install在target下出现: 项目名-版本-assembly.tar.gz压缩包 把压缩包复制到window或linux中window中使用start.bat启动,关闭命令窗口关闭服务.linux中使用start.sh启动使用stop.sh关闭. Dubbo超时问题https://www.cnblogs.com/xuwc/p/8974709.html","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://Zhangbingwu.github.io/tags/Dubbo/"}]},{"title":"Maven项目热部署","slug":"Maven项目热部署","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-12T09:41:13.972Z","comments":true,"path":"2019/08/12/Maven项目热部署/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/12/Maven项目热部署/","excerpt":"","text":"。。。今天在学习maven后，自己操作遇到了种种问题，也有很多小问题，但是记录一下，以及我成功的完整步骤，以后不能再次犯。 在使用maven部署web项目时 maven的conf中setting配置文件，本地仓库配置。注意：应该是左斜杠 /直接复制路径是 \\&lt;localRepository&gt;D:/study/maven_repository/repository&lt;/localRepository&gt; 在linux上对项目热部署 1.首先在虚拟机中，启动tomcat，在本机浏览器访问时出现tomcat主页面，这个页面其实是tomcat/webapps/manager中的。 2.在主页面进入Manager App时，需要进行以下步骤。原因：默认情况下，只能从与Tomcat在同一台计算机上运行的浏览器访问Manager。如果要修改此限制，则需要编辑Manager的context.xml文件。 进入tomcat/webapps/manager/META-INF 编辑context.xml 1234&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;&lt;/Context&gt; 进入 tomcat/conf 编辑tomcat-users.xml 1234&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script&quot;/&gt;&lt;/tomcat-users&gt; 其中 manager-gui 具有访问图形界面的权力manager-script 可以使用脚本进行更改的权力设置进入Manager App 用户名和密码 然后再次启动tomcat，本地访问输入密码就能进入。http://192.168.000.000:8080/manager/html 其中：/html 就是一个命令 ，/text 是部署时的命令 3.在项目中pom.xml中配置tomcat123456789101112&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;path&gt;/rbac&lt;/path&gt; &lt;!--注意这里是发布到tomcat的项目名--&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;url&gt;http://192.168.000.000:8080/manager/text&lt;/url&gt; &lt;!--发布地址--&gt; &lt;/configuration&gt;&lt;/plugin&gt; 注意： 使用 tomcat7:deploy 发布到tomcat的项目名不能重复如果重复可以使用 tomcat7:redeploy如果上面路径配置 / 那就是tomcat中的webapps中的ROOT文件夹需要redeploy 4.然后就可以发布了。 数据库连接问题 这里数据库连接不能使用localhost或127.0.0.1 这是只能本机访问，需要使用本机IP。 查看本机IPwin+r打开cmd ipconfig/all可以查看本机IP，连接WIFI就是无线网络适配器中的IPV4. 数据库mysql库中user表root用户连接需要改为任意 % mysql命令操作： 12grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;密码&apos; WITH GRANT OPTION;flush privileges; //刷新配置 数据库可以连接了。linux中项目访问本地数据库。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Zhangbingwu.github.io/categories/随笔/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://Zhangbingwu.github.io/tags/Maven/"}]},{"title":"Maven","slug":"Maven","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-12T09:04:18.305Z","comments":true,"path":"2019/08/12/Maven/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/12/Maven/","excerpt":"","text":"Ant1.Ant 和 Maven 都是项目构建工具2.在项目的运行编辑打包等过程都需要依赖于 Ant 构建工具 分布式 传统项目部署: 新建一个项目,通过不同的包区分不同的模块. 把这一个项目发布服务器的 tomcat 中. 分布式项目部署:(适用于高负载情况下)把一个完整的项目拆分成多个项目,把拆分后的项目分别部署到对应的服务器(tomcat)中的过程就叫做分布式项目部署. Maven 简介 基于 Ant 的构建工具,Ant 有的功能 Maven 都有,额外添加了其他功能. 本地仓库:计算机中一个文件夹,自己定义是哪个文件夹. 中央仓库:网上地址:https://repo1.maven.org/maven2/ 下载速度慢–&gt; 配置国内镜像 保证 JDK 版本和开发环境一致,如果不配置 1.4 或 1.5 远程仓库:Maven私服 坐标 每一 jar 文件都有一个唯一坐标.通过坐标可以精确确定是哪个 jar 坐标组成 GroupID: 公司名.公司网址倒写 ArtifactID: 项目名 Version: 版本 pom 项目对象模型(Project Object Mode) 把 project 当作对象看待. 通过 maven 构建工具可以让对象(项目)和对象(项目)之间产生关系 Packaging: 项目的类型,最终会被打包成什么类型. jar:java 项目 war:web 项目 pom:逻辑父项目 只要一个项目有子项目必须是 pom 类型. Maven 项目之间的关系依赖关系 标签&lt;dependency&gt;把另一个项目的 jar 引入到当过前项目 自动下载另一个项目所依赖的其他项目 继承关系 父项目是 pom 类型 子项目jar或war,如果子项目还是其他项目的父项目,子项目也是 pom 类型. 有继承关系后,子项目中出现&lt;parent&gt;标签如果子项目和`&lt;groupId&gt;`和`&lt;version&gt;`与父项目相同,在子项目中可以不配置`&lt;groupId&gt;`和`&lt;version&gt;` 父项目 pom.xml 中是看不到有哪些子项目.在逻辑上具有父子项目关系. 聚合关系 前提是继承关系.父项目会把子项目包含到父项目中. 子项目的类型必须是 Maven Module 而不是 Maven project 具有聚合关系的父项目,在 pom.xml 中&lt;modules&gt;标签指明子项目 聚合项目和继承项目区别 在语意上聚合项目父项目和子项目关系性较强 在语意上单纯继承项目父项目和子项目关系性较弱 写在父项目 作用:声明可能使用到的所有 jar 子项目中只需要有坐标的&lt;groupid&gt;和&lt;artifactid&gt;,&lt;version&gt;继承父项目 在父项目中把所有版本好进行统一管理父项目 pom.xml `&lt;properties&gt;` 子标签名称自定义 ${名字} 引用标签的值资源拷贝插件 maven指对resources文件夹内的进行解析，如果在mapper中使用Mapper.xml就需要在pom.xml中配置资源拷贝插件。 如果进行配置，就不会对resources中内容解析，需要自己配置。123456789101112131415161718&lt;build&gt;&lt;!--资源拷贝插件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Tomcat配置maven启动命令 clean tomcat7:runclean清除之前的编译，target文件夹。 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;path&gt;/rbac&lt;/path&gt; &lt;/configuration&gt;&lt;/plugin&gt; 常用pom.xml配置依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;servlet-version&gt;3.0.1&lt;/servlet-version&gt; &lt;jsp-version&gt;2.2&lt;/jsp-version&gt; &lt;jstl-version&gt;1.2&lt;/jstl-version&gt; &lt;spring-version&gt;4.1.6.RELEASE&lt;/spring-version&gt; &lt;aspectjweaver-version&gt;1.8.6&lt;/aspectjweaver-version&gt; &lt;mybatis-version&gt;3.2.7&lt;/mybatis-version&gt; &lt;mybatis-spring-version&gt;1.2.3&lt;/mybatis-spring-version&gt; &lt;log4j-version&gt;1.2.17&lt;/log4j-version&gt; &lt;mysql-connector-java-version&gt;8.0.16&lt;/mysql-connector-java-version&gt; &lt;jackson-version&gt;2.4.1&lt;/jackson-version&gt; &lt;commons-fileupload-version&gt;1.3.1&lt;/commons-fileupload-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectjweaver-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis和spring整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动类 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- apache 图片上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://Zhangbingwu.github.io/tags/Maven/"}]},{"title":"Linux","slug":"Linux","date":"2019-08-10T16:00:00.000Z","updated":"2019-08-11T13:11:16.683Z","comments":true,"path":"2019/08/11/Linux/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/11/Linux/","excerpt":"","text":"Linux简介 1.所谓的linux都是统称，具体版本都叫做发行版。 red hat ：目前全球最大的linux发行厂商（收费） ubuntu：免费，界面好。 麒麟 cent os 免费，redhat 分支。 2.定位 操作系统. 适合于服务器系统,不适合办公系统. 3.linux 相对 window 优点 稳定. 安全性比较高 免费. 系统目录介绍 / 根目录 ~ /root etc 存放系统配置目录 home 除了root以为所有用户默认在home下新建一个以用户名做为文件夹名称的文件夹。 用户 xxx 对/home/xxx具有完全操作权限. root 用户root单独文件夹 usr 所有用户安装的软件都放入到这个文件夹中在usr/local下新建一个tmp,所有压缩包都上传到tmp中. 常用命令 pwd 打印工作目录，当前所有文件夹全路径 cd 进入文件夹 cd .. 退出当前文件夹 mkdir 新建空文件夹 ls 平铺显示当前文件夹内容 ll 显示详细信息 vi 和 vim 都是编辑文件如果文件不存在,带有创建文件功能vi 普通编辑 vim 高级编辑(带有颜色)进入到编辑器后非可编辑状态,键盘insert启用编辑状态 ：wq 保存并退出：q 退出：q! 强制退出 touch 创建空文件 cat 在命令行中查看文件全部内容 head [-n] 文件名 查看文件前n行，默认10行 tail [-n] 文件名 查看文件后n行，默认10行 tailf 动态显示文件(tomcat日志文件) echo ‘内容’ &gt;&gt; 文件名 向文件中添加一些内容 ifconfig 打印网卡信息，查询当前ip reboot 重启 tar zxvf 文件名 解压缩v 解压过程显示 zip unzip 压缩 解压 cp [-r] 原文件 新文件路径 -复制文件，复制文件夹需要加-r ctrl+c 中断 mv 原文件 新文件 -剪切，移动 可以用来修改文件名字 rm [-r][-f] 文件名 -移除文件，加-r移除目录 ，加-f不提示直接移除，-rf clear 清屏 不同用户登录root用户 显示 #普通用户 显示 $ Xshell linux 客户端工具. CentOS 中默认只开启 22 端口.其他端口都被防火墙拦截. Filezilla 1.FTP协议 (FileTransfer Protocol）文件传输协议 作用:互联网中,计算机之间传输文件需要遵守的协议. 2.fileziila 基于 FTP 协议的客户端工具. 使用 filezilla 可以快速完成文件传输功能. 修改环境变量，防火墙修改环境变量 1.# vim/etc/profile 2.文件内容 export 添加或修改变量 多个变量之间 : 隔开，不像windows ; $变量名 表示引用 1234#exportPATHUSERLOGNAMEMAILHOSTNAMEHISTSIZEHISTCONTROLexport JAVA_HOME=/usr/local/jdk7export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 修改后需要解析文件(或重启系统)source /etc/profile 防火墙 vim /etc/sysconfig/iptables 8080:9000 表示从8080到9000全放行 修改后重启防火墙service iptables restart 启动tomcat linux中 .sh 表示可执行文件 ./startup.sh 启动tomcat ./startup.sh &amp; tailf ../logs/catalina.out 启动tomcat并且显示日志 IDEA将项目打成war (非maven) 参考","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://Zhangbingwu.github.io/tags/linux/"}]},{"title":"RBAC学习","slug":"RBAC学习","date":"2019-08-09T16:00:00.000Z","updated":"2019-08-11T12:25:27.575Z","comments":true,"path":"2019/08/10/RBAC学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/10/RBAC学习/","excerpt":"","text":"RBAC 基于角色的访问控制 (Role-Based Access Control) 解释:一种思想.根据 RBAC 思想进行数据库设计,根据数据库设计更好的完成权限控制. 权限控制常用分类:菜单功能url 控制(控制访问不同的控制器)资源可见性控制(页面某些元素对不同用户可见性是不同的) 举例 原来的设计需求:新增一个用户,具有所有菜单可见的功能. 新建一个用户. 在用户-菜单关联表中把所有菜单和用户关联. 使用 rbac 思想进行设计如果需求确定每个用户只能有一个角色,在用户表中添加外键列,直接应用角色表如果每个用户可能有多个角色,按照下面进行设计.需求:新增一个用户,具有所有菜单可见的功能.项目上线时已经创建了 n 个角色,且不同角色可能看不同的菜单. 新建用户. 在用户-角色表中添加用户和角色的关系. 我的理解就和名字一样，基于角色，是把用户和诸如菜单，视图，url通过角色进行解耦。 用户只和角色有关，不同的角色对应不同的功能。 解耦后使得扩展性更强。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"RABC","slug":"RABC","permalink":"https://Zhangbingwu.github.io/tags/RABC/"}]},{"title":"springMVC学习03","slug":"springMVC学习03","date":"2019-08-08T16:00:00.000Z","updated":"2019-08-10T01:54:21.427Z","comments":true,"path":"2019/08/09/springMVC学习03/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/09/springMVC学习03/","excerpt":"","text":"自定义拦截器 interceptor 跟过滤器比较像的技术. 发送请求时被拦截器拦截,在控制器的前后添加额外功能. 2.1 跟 AOP 区分:AOP 在特定方法前后扩充(对 ServiceImpl)2.2 拦截器,请求的拦截.针对点是控制器方法.(对 Controller) SpringMVC 拦截器和 Filter 的区别 3.1 拦截器只能拦截 Controller3.2 Filter 可以拦截任何请求 实现自定义拦截器的步骤: 1.新建Interceptor类，实现HandlerInterceptor接口 public boolean preHandle执行控制器之前执行preHandle返回值 true：允许执行控制器 false：不允许执行控制器如果请求被拦截，return false，响应空内容返回客户端，响应状态码200.参数Object o 表示拦截的控制器方法 postHandle控制器执行完，跳转JSP之前执行可以用来：1.日志记录：这个控制器被访问了多少次2.敏感词汇和谐 参数：ModelAndView modelAndView 从控制器传输的Model数据，和View即将跳转的视图 modelAndView.setViewName(“/error.jsp”);重新设置跳转的视图 afterCompletion跳转JSP之后执行收集异常信息，并记录到日志中。参数：Exception e记录了控制器运行的异常信息 2.在springmvc.xml中配置拦截器 拦截所有的控制器可以配置多个拦截器 1234&lt;mvc:interceptors&gt; &lt;bean class=&quot;com.zbw.interceptor.DemoInterceptor&quot;/&gt; &lt;bean class=&quot;com.zbw.interceptor.DemoInterceptor2&quot;/&gt;&lt;/mvc:interceptors&gt; 配置拦截指定的控制器的拦截器 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/demo&quot;/&gt; &lt;bean class=&quot;com.zbw.interceptor.DemoInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器栈 多个拦截器同时生效时,组成了拦截器栈 顺序:先进后出. 执行顺序和在 springmvc.xml 中配置顺序有关 设置先配置拦截器 A 在配置拦截器 B 执行顺序为preHandle(A)–&gt; preHandle(B)–&gt; 控制器方法 –&gt;postHandle(B) –&gt;postHanle(A)–&gt;JSP–&gt;afterCompletion(B)–&gt;afterCompletion(A) springMVC对Date类型的转换 1.导入joda-time.jar 2.配置springmvc.xml 12345678910111213141516171819202122&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;formatterRegistrars&quot;&gt; &lt;set&gt; &lt;bean class=&quot;org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar&quot;&gt; &lt;property name=&quot;dateFormatter&quot;&gt; &lt;bean class=&quot;org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean&quot;&gt; &lt;property name=&quot;pattern&quot; value=&quot;yyyy-MM-dd&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 3.创建实体类注意:java.util.Date 12345678910111213141516171819import java.util.Date;public class Demo1 &#123; @DateTimeFormat(pattern=&quot;yyyy/MM/dd&quot;) private Date time; public Date getTime() &#123; return time; &#125; public void setTime(Date time) &#123; this.time = time; &#125; @Override public String toString() &#123; return &quot;Demo1 [time=&quot; + time + &quot;]&quot;; &#125;&#125; 4.控制器接收参数注意：在需要接收的参数之前@DateTimeFormat(pattern = “yyyy-MM-dd”)Date time 12345678@Controllerpublic class DemoController &#123; @RequestMapping(&quot;demo&quot;) public String aaa(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date time)&#123; System.out.println(time); return &quot;abc.jsp&quot;; &#125;&#125; 5.jsp页面提交的是text 1234&lt;form action=&quot;demo&quot; method=&quot;post&quot;&gt; 时间:&lt;input type=&quot;text&quot; name=&quot;time&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"springMVC - 自定义拦截器","slug":"springMVC-自定义拦截器","permalink":"https://Zhangbingwu.github.io/tags/springMVC-自定义拦截器/"}]},{"title":"springMVC学习02","slug":"springMVC学习02","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-09T11:41:45.687Z","comments":true,"path":"2019/08/08/springMVC学习02/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/08/springMVC学习02/","excerpt":"","text":"JSP九大内置对象复习 九大内置对象是JSP转成java文件后，在局部变量为我们定义好的。 page 当前页面 pageContext 封装了其他八个内置对象 request 封装了请求的所有信息 response 封装了响应的所有信息 Exception 异常对象 out resp.getWriter()获得的用于输出字符流的对象 session req.getSession() 封装了所有会话的信息 application 所有信息 getServletContext();req.getServletContext; config 配置信息 四大作用域对象 page 当前页面内不会重新实例化。 request 一次请求中不会重新实例化。 session 一次会话中不会重新实例化。 1.客户端中Cookie保留的JSESSIONID和服务器中一致，session就不会重新实例化。(在默认时间内)浏览器关闭（cookie失效） 默认时间内，没有交互。 2.默认时间在web.xml中修改，&lt;session-config&gt;标签。 application 服务器启动时实例化，服务器关闭销毁。 SpringMVC作用域传值1.原生Servlet1234567@RequestMapping(&quot;demo&quot;)public String demo(HttpServletRequest req, HttpServletResponse resp)&#123; req.setAttribute(&quot;req&quot;,&quot;req的值&quot;); req.getSession().setAttribute(&quot;session&quot;,&quot;session的值&quot;); req.getServletContext().setAttribute(&quot;application&quot;,&quot;application的值&quot;); return &quot;/index.jsp&quot;;&#125; 2.Map传值 把 map 中内容放在 request 作用域中${requestScope.map} spring 会对 map 集合通过 BindingAwareModelMap 进行实例化 也可以放对象，集合。 123456@RequestMapping(&quot;demo2&quot;)public String demo2(Map&lt;String,Object&gt; map)&#123; System.out.println(map.getClass()); map.put(&quot;map&quot;,&quot;map的值&quot;); return &quot;/index.jsp&quot;;&#125; class org.springframework.validation.support.BindingAwareModelMap 3.Model SpringMVC 中 Model 接口 把内容最终放入到 request 作用域中12345@RequestMapping(&quot;demo3&quot;)public String demo3(Model model)&#123; model.addAttribute(&quot;model&quot;,menuServiceImpl.show()); return &quot;/index.jsp&quot;;&#125; 4.ModelAndView SpringMVC 中 ModelAndView 类 把内容最终放入到 request 作用域中1234567@RequestMapping(&quot;demo4&quot;)public ModelAndView demo4()&#123; //参数为 要跳转的视图 ModelAndView mav = new ModelAndView(&quot;/index.jsp&quot;); mav.addObject(&quot;mav&quot;,&quot;mav的值&quot;); return mav;&#125; 文件的上传与下载文件下载 设置响应头中Content-Disposition为attachment 文件为下载类型fileName就是下载时显示的文件名称 response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;fileName=&quot;+fileName); 浏览器默认为 inline 能显示就显示，显示不了就下载。 获得文件夹的绝对路径String path = request.getServletContext().getRealPath(&quot;files&quot;); 将文件转为二进制流byte[] bytes = FileUtils.readFileToByteArray(new File(path, fileName)); 获得响应输出流并写出 12ServletOutputStream os = response.getOutputStream();os.write(bytes); 注意：需要在springmvc中放行静态资源files&lt;mvc:resources location=&quot;/files/&quot; mapping=&quot;/files/**&quot;/&gt; 文件上传 基于 apache 的 commons-fileupload.jar 完成文件上传. MultipartResovler 作用:把客户端上传的文件流转换成 MutipartFile 封装类.通过 MutipartFile 封装类获取到文件流 表单数据类型分类在&lt;form&gt;的 enctype 属性控制表单类型 默认值 application/x-www-form-urlencoded,普通表单数据.(少量文字信息) text/plain 大文字量时使用的类型.邮件,论文 multipart/form-data 表单中包含二进制文件内容. 实现步骤: 导入 springmvc 包和 apache 文件上传 commons-fileupload 和commons-io 两个 jar 编写 JSP 页面上传: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; 注意：这里的name的值，必须和 MultipartFile 的参数名称相同 配置 springmvc.xmlMutipartResovler解析器 12345&lt;!-- MultipartResolver解析器 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--设置最大上传大小 1024字节 1k--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;1024&quot;/&gt;&lt;/bean&gt; 异常解析器private Properties exceptionMappings;对Properties类型设置注入。&lt;prop key=异常全称&gt;跳转的页面&lt;/prop&gt; 12345678 &lt;!-- 异常解析器 --&gt;&lt;bean id=&quot;exceptionResolver&quot; class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;org.springframework.web.multipart.MaxUploadSizeExceededException&quot;&gt;/error.jsp&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 编写控制器controller 1234567891011121314151617public String register(Users users, MultipartFile file)&#123; //获取文件名称 如:a.png String fileName = file.getOriginalFilename(); //截取文件后缀 如:.png String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //为文件存储时设置名称，UUID静态工厂随机生成UUID对象，并返回此UUID的String对象 String uuid = UUID.randomUUID().toString(); String path = request.getServletContext().getRealPath(&quot;images&quot;)+&quot;/&quot;+uuid+suffix; //在controller处理异常 try &#123; FileUtils.copyInputStreamToFile(file.getInputStream(),new File(path)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //jsp只能取到服务器发布的文件，不能取本地文件,将照片对应的UUID存入数据库。 users.setPhoto(uuid); int index = usersServiceImpl.insUsers(users);","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"springMVC - 文件上传与下载","slug":"springMVC-文件上传与下载","permalink":"https://Zhangbingwu.github.io/tags/springMVC-文件上传与下载/"}]},{"title":"springMVC学习01","slug":"springMVC学习01","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-07T12:55:57.691Z","comments":true,"path":"2019/08/07/springMVC学习01/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/07/springMVC学习01/","excerpt":"","text":"SpringMVC简介SpringMVC 中重要组件 DispatcherServlet:前端控制器,接收所有请求(如果配置 / 不包含 jsp)对请求做过滤。 HandlerMapping:解析请求格式的.判断希望要执行哪个具体的方法. HandlerAdapter:负责调用具体的方法. ViewResovler:视图解析器.解析结果,准备跳转到具体的物理视图 SpringMVC 运行原理 DispatcherServlet接收请求，如果符和匹配进行拦截，交给HandlerMapping对请求进行解析，判断有没有匹配的方法去执行，判断完成后交给HandlerAdapter根据判断对Controller中方法进行调用，ViewResovler解析并跳转的具体的物理视图给浏览器。 spring容器和springMVC容器的关系 父子关系 spring容器是springMVC的父容器 SpringMVC 容器中能够调用 Spring 容器的所有内容 applicationContext spring容器webApplicationContext spring整合web后容器configableWebApplicationContext springMVC容器 springMVC环境搭建1.导包 spring-webmvc.jar 2.在web.xml中配置DispatcherServlet / 会过滤除了jsp等所有请求 如果没有init-param 会在/WEB-INF/&lt;servlet-name&gt;-servlet.xml如 abc-servlet.xml12345678910111213 &lt;servlet&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置springmvc.xml 注意在src下创建，名字必须和init-param标签的子标签param-value的路径及名称相同。 需要引入xmlns:mvc 注解配置，需要配置注解扫描。 注解驱动 静态资源 因为DispatcherServlet会把除了jsp的资源都过滤掉，想要访问静态资源必须进行配置。 mapping是请求url匹配 如/js/jquery.js **表示jquery.js 示例123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 扫描注解--&gt; &lt;context:component-scan base-package=&quot;com.zbw.controller&quot;/&gt;&lt;!-- 注解驱动--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 静态资源 --&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt;&lt;/beans&gt;``` # spring字符编码过滤器- 在web.xml中配置 &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;12- CharacterEncodingFilter可以用init-param标签设置参数。 public class CharacterEncodingFilter extends OncePerRequestFilter { private String encoding; private boolean forceEncoding = false; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) { request.setCharacterEncoding(this.encoding); if (this.forceEncoding) { response.setCharacterEncoding(this.encoding); } } filterChain.doFilter(request, response); }} 12345678910111213141516# 传参- 内容写到方法HandlerMethod的参数中,SpringMVC只要有这个内容,就会注入内容.- 1.基本数据类型参数1. 默认保证参数名称和请求中传递的参数名相同 2. 如果请求参数名和方法参数名不对应使用@RequestParam()赋值3. 如果方法参数是基本数据类型(不是封装类)可以通过@RequestParam 设置默认值. 防止没有参数时 5004. 如果强制要求必须有某个参数 (@RequestParam(required=true) - 2.HandlerMethod 中参数是对象类型 请求参数名和对象中属性名对应(get/set 方法)- 3.请求参数为 对象.属性 格式 &lt;input type=&quot;text&quot; name=&quot;user.name&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;user.pwd&quot;/&gt;1用一个由user这个属性的对象来接。 public class People { private User user;12345- 4.请求参数中包含多个同名参数的获取方式 复选框传递的参数就是多个同名参数 @RequestParam(&quot;参数名&quot;) 可以用List集合接，也可以用数组String[]接。 @RequestMapping(&quot;demo4&quot;) public String demo4(@RequestParam(&quot;fav&quot;) List&lt;String&gt; abc){ System.out.println(abc); return &quot;main.jsp&quot;; }1- 5.在请求参数中传递集合对象类型参数 public class People { private List&lt;User&gt; user;12345``` &lt;input type=&quot;text&quot; name=&quot;user[0].name&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;user[0].pwd&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;user[1].name&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;user[1].pwd&quot;/&gt; People{user=[User{name=&#39;1&#39;, pwd=&#39;1&#39;}, User{name=&#39;2&#39;, pwd=&#39;2&#39;}]} 6.restful方式 在@RequestMapping 中一定要和请求格式对应 @PathVariable 获取@RequestMapping 中内容,默认按照方法参数名称去寻找。 例如:&lt;a href=&quot;demo5/123/张&quot;&gt;跳转&lt;/a&gt; 123456//restful方式 @RequestMapping(&quot;/demo5/&#123;id&#125;/&#123;name2&#125;&quot;) public String demo5(@PathVariable(&quot;id&quot;) int id,@PathVariable(&quot;name2&quot;) String name)&#123; System.out.println(id+&quot;-&quot;+name); return &quot;main.jsp&quot;; &#125; 跳转方式 默认跳转方式请求转发. 设置返回值字符串内容添加 redirect:资源路径 重定向添加 forward:资源路径 或省略 forward: 转发return &quot;redirect:main.jsp&quot;; 视图解析器 SpringMVC 会提供默认视图解析器. 程序员自定义视图解析器InternalResourceViewResolver12345&lt;!--自定义视图解析器--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; 注意：如果希望不执行自定义视图解析器,在方法返回值前面添加forward:或 redirect:比如：希望跳转的不是jsp文件而是html，return forward:main.html; @ResponseBody 在方法上只有@RequestMapping 时,无论方法返回值是什么认为需要跳转.如果没有返回值，即void： 1234567@RequestMapping(value = &quot;demo6&quot;) public void demo6(HttpServletResponse response) throws IOException &#123; PrintWriter out = response.getWriter(); out.write(&quot;abc&quot;); out.flush(); out.close(); &#125; 在方法上添加@ResponseBody(恒不跳转) 如果返回值满足 key-value 形式(对象或 map) 自动把响应头设置为 application/json;charset=utf-8 自动把转换后的内容输出流的形式响应给客户端. 如果返回值不满足 key-value,例如返回值为 String 把相应头设置为 text/html 把方法返回值以流的形式直接输出. 如果 返回值 包含中文,出现中文乱码@RequestMapping中属性 produces 表示响应头中 Content-Type 取值.12345@RequestMapping(value = &quot;demo6&quot;,produces = &quot;text/html;charset=utf-8&quot;)@ResponseBodypublic String demo6()&#123; return &quot;哈哈&quot;;&#125; 注意：@ResponseBody底层使用jackson解析，需要导入相关jar。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"springMVC","slug":"springMVC","permalink":"https://Zhangbingwu.github.io/tags/springMVC/"}]},{"title":"单例设计模式","slug":"单例设计模式","date":"2019-08-05T16:00:00.000Z","updated":"2019-08-06T10:05:32.145Z","comments":true,"path":"2019/08/06/单例设计模式/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/06/单例设计模式/","excerpt":"","text":"单例设计模式作用在应用程序中保证最多只能有一个实例。 好处 提高了运行效率 实现了数据共享，例如：application对象。 懒汉式对象只有被调用时才去创建。 由于添加了锁,所以导致效率低。 代码12345678910111213141516171819202122232425262728293031public class SingleTon &#123; private static SingleTon singleTon; /** * 为了不让外界可以实例化，构造方法私有化 */ private SingleTon()&#123;&#125; /** * 为了让外界可以获取到对象，提供一个入口 * 为了让外界获取到该方法，即通过对象调用该方法，应设置方法为static */ public static SingleTon getInstance()&#123; /* * 逻辑判断，如果对象已经被实例化，即存在，就返回该对象的引用。 */ if(singleTon==null)&#123; /* 如果多线程情况，多个线程同时判断为null，仍会实例化多个对象，因此加锁。 */ synchronized (SingleTon.class)&#123; /* 多线程，多个线程都判断为null，进入了判断，等待后都会实例化，因此加双重判断。 */ if(singleTon==null)&#123; singleTon = new SingleTon(); &#125; &#125; &#125; return singleTon; &#125;&#125; 饿汉式好处：避免了懒汉式使用锁导致效率低的问题12345678910public class SingleTon2 &#123; /** * 在类加载的时候实例化 */ private static SingleTon2 singleTon2 = new SingleTon2(); private SingleTon2()&#123;&#125; public static SingleTon2 getInstance()&#123; return singleTon2; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://Zhangbingwu.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://Zhangbingwu.github.io/tags/设计模式/"}]},{"title":"代理设计模式","slug":"代理设计模式","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-05T13:22:03.278Z","comments":true,"path":"2019/08/05/代理设计模式/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/05/代理设计模式/","excerpt":"","text":"什么是设计模式？前人总结的一套解决特定问题的方法。 代理设计模式 真实对象 代理对象 抽象对象（抽象功能） 代理设计模式的优点 保护了真实对象 让真实对象的职责更加明确 具有扩展性 静态代理设计模式 有代理对象代理所有真实对象的功能 缺点当代理功能比较多时，代理类中方法需要写很多。 动态代理模式 为了解决静态代理频繁写代理功能的缺点。 1.JDK提供的动态代理模式 与cglib相比优点： jdk自带，无需导入jar缺点： 真实对象必须实现接口。 利用反射机制，效率不高。1234567891011//真实对象public class Laozong implements Gongnneg&#123; public String chifan()&#123; System.out.println(&quot;吃饭&quot;); return &quot;我忙&quot;; &#125; @Override public void mubiao() &#123; System.out.println(&quot;目标&quot;); &#125;&#125; 123456789101112//代理对象(处理程序)public class Mishu implements InvocationHandler &#123; private Laozong laozong = new Laozong(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;预约&quot;); Object o = method.invoke(laozong, args); System.out.println(&quot;记录&quot;); System.out.println(o); return o; &#125;&#125; 12345678910public class Wo &#123; public static void main(String[] args) &#123; Mishu mishu = new Mishu(); //第一个参数：反射使用的类加载器 //第二个参数：代理类Proxy需要实现什么接口 //第三个接口：通过接口对象调用方法时，需要调用哪个类的invoke方法。调用哪个处理程序 Gongnneg gongnneg = (Gongnneg) Proxy.newProxyInstance(Wo.class.getClassLoader(), new Class[]&#123;Gongnneg.class&#125;, mishu); gongnneg.chifan(&quot;你好&quot;); &#125;&#125; cglib动态代理模式优点： cglib是直接生成一个真实对象的子类的字节码文件，因此调用更快，运行效率高。 真实对象不用实现接口。 导包asm.jar 反编译包cglib.jar 123456//真实对象public class Laozong &#123; public void chifan()&#123; System.out.println(&quot;吃饭&quot;); &#125;&#125; intercept(生成子类的对象,代理的方法,方法的参数,子类生成的方法)注意： method.invoke()是真实对象的方法 methodProxy.invokeSuper()是生成的子类的方法调用父类真实对象的方法。 不能写成methodProxy.invoke()会出现死循环。 这个Mishu类就相当于子类 123456789public class Mishu implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;预约&quot;); Object result = methodProxy.invokeSuper(o, objects); System.out.println(&quot;备注&quot;); return result; &#125;&#125; 123456789public class Wo &#123; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Laozong.class); //设置调用的父类 enhancer.setCallback(new Mishu()); //设置回调(对象) Laozong laozong = (Laozong) enhancer.create(); //生成子类 laozong.chifan(); &#125;&#125; 在aop中注意，默认使用jdk动态代理，是让Proxy实现接口，而在servlet使用时，通过ac.getBean(“”,impl.class)进行强转，报错。应该设置为cglib动态代理。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://Zhangbingwu.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://Zhangbingwu.github.io/tags/设计模式/"}]},{"title":"Spring学习03","slug":"Spring学习03","date":"2019-08-04T16:00:00.000Z","updated":"2019-08-06T12:25:09.480Z","comments":true,"path":"2019/08/05/Spring学习03/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/05/Spring学习03/","excerpt":"","text":"spring中的 自动注入 在Spring配置文件中对象名和ref=”id”id名相同使用自动注入,可以不配置&lt;property/&gt;注意：只有ref属性 default-autowire=””的五个取值 no不自动注入 default默认值,根据全局default-autowire=””值.默认全局和局部都没有配置情况下,相当于 no。 byName通过名称自动注入.在 Spring容器(可以通过ac.getDeac.getBeanDefinitionNames()查看当前spring容器中管理的类。 byType根据类型注入。如果使用这个spring 容器中不可以出现两个相同类型的&lt;bean&gt; constructor根据构造方法注入。需要提供对应参数的构造方法。底层使用 byName。构造方法参数名和其&lt;bean&gt;的 id相同. 全局配置自动注入beans 标签下添加 default-autowire=”byName” Spring 中加载 properties 文件 需要在src下有资源文件 1234&lt;!-- 资源文件路径--&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties,classpath:info.propeties&quot;/&gt;&lt;!-- 注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.zbw.service.impl&quot;/&gt; 使用${资源文件中key名}获取资源文件对应的值。 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.userpassword&#125;&quot;/&gt;&lt;/bean&gt; 添加扫描器属性sqlSessionFactoryBeanName 12345&lt;!-- 扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zbw.mapper&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;factory&quot;/&gt; &lt;/bean&gt; 注意： SqlSessionFactoryBean 的 id 不能叫做 sqlSessionFactory。 在配置资源路径时：多个资源路径之间逗号隔开,不能省略classpath:,这表示从src下去寻找。 &lt;context:property-placeholder location=&quot;classpath:db.properties,classpath:info.propeties&quot;/&gt; 从代码中获取资源文件中的值。资源文件中12user.birthday=1998-02-20user.age=22 从代码中获取 1234@Value(&quot;$&#123;user.birthday&#125;&quot;)private String birthday;@Value(&quot;$&#123;user.age&#125;&quot;)private int age; 为什么不用sqlSessionFactory?因为自动注入优先级太高，spring在加载全局配置文件时，会先将要管理的对象初始化，sqlSessionFactory要使用就要使用ref引用factory对象，这样数据源就不能获取到资源文件中的值。bean标签的scope属性作用控制对象实例化时的有效范围（单例还是多例）。bean标签的scope属性默认是单例的，也就是一个bean不论获取几次，都是同一个对象。 scope 可取值 singleton 默认值,单例 prototype 多例,每次获取重新实例化 request 每次请求重新实例化 session 每个会话对象内,对象是单例的. application 在 application 对象内是单例 globalsession spring推出的一个对象,依赖于spring-webmvc-portlet,类似于 session 声明式事务编程式事务 由程序员控制事务的开启，提交和回滚。如：openSessionInView编程式事务 声明式事务 事务控制代码由spring写好，程序员只用声明那些方法需要声明事务控制，以及如何进行控制。 声明式事务针对ServiceImpl类下的方法。 事务管理器是基于通知(advice)的。 声明式事务配置 步骤 数据源配置dataSource 事务管理配置 DataSourceTransactionManager 1234&lt;!--事务管理--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 基于通知的声明式事务 1234567891011&lt;!--配置声明式事务--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt;&lt;!--那些方法需要由事务控制--&gt;&lt;!--方法名ins开头的方法由事务控制--&gt; &lt;tx:method name=&quot;ins*&quot;/&gt; &lt;tx:method name=&quot;del*&quot;/&gt; &lt;tx:method name=&quot;upd*&quot;/&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 属性解析 name=””哪些方法需要有事务控制支持*通配符 readonly=”boolean” 是否为只读事务.如果为 true,告诉数据库此事务为只读事务.数据层面的优化,会对性能有一定提升,所以只要是查询的方法,建议使用此数据。如果为 false(默认值),事务需要提交的事务.建议新增,删除,修改. propagation 控制事务传播行为. 3.1 什么是控制事务传播行为?当一个具有事务控制的方法被另一个有事务控制的方法调用后,需要如何管理事务(新建事务?在事务中执行?把事务挂起?报异常?)前提:当一个具有事务控制的方法被另一个有事务控制的方法调用。 3.2REQUIRED(默认值): 如果当前有事务,就在事务中执行,如果当前没有事务,新建一个事务.3.3 SUPPORTS:如果当前有事务就在事务中执行,如果当前没有事务,就在非事务状态下执行.3.4 MANDATORY:必须在事务内部执行,如果当前有事务,就在事务中执行,如果没有事务,报错.3.5 REQUIRES_NEW:必须在事务中执行,如果当前没有事务,新建事务,如果当前有事务,把当前事务挂起.3.6 NOT_SUPPORTED:必须在非事务下执行,如果当前没有事务,正常执行,如果当前有事务,把当前事务挂起.3.7 NEVER:必须在非事务状态下执行,如果当前没有事务,正常执行,如果当前有事务,报错.3.8 NESTED:必须在事务状态下执行.如果没有事务,新建事务,如果当前有事务,创建一个嵌套事务. isolation=”” 事务隔离级别为什么会有事务隔离级别?因为事务操作中存在问题：脏读，不可重复读，幻读。 1.DEFAULT: 默认值,由底层数据库自动判断应该使用什么隔离界别。oracle默认读取已提交，mysql默认可重复读。2.READ_UNCOMMITTED: 可以读取未提交数据,可能出现脏读,不重复读,幻读.这种级别下，效率最高.3.READ_COMMITTED:只能读取其他事务已提交数据.可以防止脏读,可能出现不可重复读和幻读.4.REPEATABLE_READ: 读取的数据被添加锁,防止其他事务修改此数据,可以防止不可重复读.脏读,可能出现幻读.5.SERIALIZABLE: 排队操作,对整个表添加锁.一个事务在操作数据时,另一个事务等待事务操作完成后才能操作这个表.这种级别下：最安全，效率最低的. rollback-for=”异常类型全限定路径” 如rollback-for=”java.lang.Exception” 1 当出现什么异常时需要进行回滚 2 建议:给定该属性值. 手动抛异常一定要给该属性值. 手动抛异常：让程序终止的一种方法， throw new Exception(); no-rollback-for=”异常类型全限定路径”当出现什么异常时不滚回事务. Spring 中常用注解. @Component 创建类对象,相当于配置&lt;bean/&gt; @Service 与@Component 功能相同.写在 ServiceImpl 类上. @Repository 与@Component 功能相同.写在数据访问层类上. @Controller 与@Component 功能相同.写在控制器类上. @Resource(不需要写对象的 get/set)java 中的注解默认按照 byName 注入,如果没有名称对象,按照 byType 注入建议把对象名称和 spring 容器中对象名相同 @Autowired(不需要写对象的 get/set)spring 的注解默认按照 byType 注入. @Value() 获取 properties 文件中内容 @Pointcut() 定义切点 @Aspect() 定义切面类 @Before() 前置通知 @After 后置通知 @AfterReturning 后置通知,必须切点正确执行 @AfterThrowing 异常通知 @Arround 环绕通知","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"声明式事务","slug":"声明式事务","permalink":"https://Zhangbingwu.github.io/tags/声明式事务/"}]},{"title":"Spring学习02","slug":"Spring学习02","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-05T16:18:33.458Z","comments":true,"path":"2019/08/04/Spring学习02/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/04/Spring学习02/","excerpt":"","text":"spring整合mybatis导包 1.导入mybatis需要的jar，spring核心jar和日志jar。 2.整合数据访问层必须导入spring-jdbc.jar 3.整合web必须要导入spring-web.jar 4.以及aop，tx。 配置文件1.配置web.xml 1.servlet由tomcat服务器管理，所以不能交由spring管理，那么怎么样获得spring创建的对象？ spring为我们封装了一个监听器，来帮助我们加载spring配置文件，即applicationContext.xml。 创建监听器的时候，加载了spring配置文件，并创建了webApplicationContext。 spring和web整合后，所有的信息都存放在webApplicationContext中 ContextLoaderListener源码注解： 12//* Create a new &#123;@code ContextLoaderListener&#125; that will create a web application//* context based on the &quot;contextClass&quot; and &quot;contextConfigLocation&quot; servlet context-params. 具体web.xml配置 12345678&lt;!--spring封装了一监听器，帮助加载spring配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.配置applicationContext.xml 1.因为IoC控制反转，spring可以帮助我们管理需要的对象，因此可以将mybatis.xml中的配置信息，也就是一些类交由spring管理。 管理dataSource，也就是数据库连接信息,spring封装了jdbc，只需要通过设置注入连接需要的信息让它创建连接对象即可。DriverManagerDataSource 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sorm?serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;670322387&quot;/&gt;&lt;/bean&gt; 接下来就是创建SqlSessionFactory对象。SqlSessionFactoryBean 1234&lt;bean id=&quot;factory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--引用dataSource数据库连接信息--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 扫描器，相当于mybatis.xml中mappers下package标签，扫描指定的包后会为其对应的接口创建对象MapperScannerConfigurer 12345&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zbw.mapper&quot;/&gt; &lt;!--与sqlSessionFactory关联--&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;factory&quot;/&gt;&lt;/bean&gt; spring还可以管理service层，通过创建service实现类。service实现类中需要调用mapper层以获得从数据库查询的数据，因此需要DI依赖注入依赖由spring扫描mapper包后创建的对象。”接口名首字母小写” 123&lt;bean id=&quot;airportServiceImpl&quot; class=&quot;com.zbw.service.impl.AirportServiceImpl&quot;&gt; &lt;property name=&quot;airportMapper&quot; ref=&quot;airportMapper&quot;/&gt;&lt;/bean&gt; 测试在servlet初始化时，实例化service，就是从webApplicationContext中取出spring帮我们创建的对象。 WebApplicationContextUtils是spring提供的用于从servletContext获取webApplicationContext的的工具。12345@Override public void init() throws ServletException &#123; ApplicationContext ac = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext()); airportService = ac.getBean(&quot;airportServiceImpl&quot;, AirportServiceImpl.class); &#125; AOP什么是AOP？ AOP (Aspect Oriented Programing) 面向切面编程 理解 正常的程序执行流程都是纵向的，自上而下。 在原有的纵向执行流程中添加横切面。 在程序原有纵向执行流程中,针对某一个或某一些方法添加通知,形成横切面过程就叫做面向切面编程. 特点 1.不需要修改原有的代码。 2.使程序具有高扩展性。 3.原有功能释放了部分逻辑，使职责更加明确。(将原来复杂的功能(方法)中部分逻辑代码在其前后进行分担) 常用概念 原有功能: 切点,pointcut 前置通知: 在切点之前执行的功能.beforeadvice 后置通知: 在切点之后执行的功能,afteradvice 如果切点执行过程中报出异常,会触发异常通知.throwsadvice 所有功能总称叫做 切面. 织入: 把切面嵌入到原有功能的过程叫做 织入 spring提供了2种AOP实现方式Schema-based 每个通知都需要实现接口或类 配置 spring 配置文件时在&lt;aop:config&gt;配置 通配符* (..)匹配任意参数例：想要拦截com.zbw.test包下的所有类可以：(* com.zbw.test.*.*(..)) 12345678&lt;!--配置切面--&gt; &lt;aop:config&gt;&lt;!--配置切点--&gt; &lt;aop:pointcut id=&quot;myPoint&quot; expression=&quot;execution(* com.zbw.test.Demo.*(..))&quot;/&gt;&lt;!--通知--&gt; &lt;aop:advisor advice-ref=&quot;myBefore&quot; pointcut-ref=&quot;myPoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;myAfter&quot; pointcut-ref=&quot;myPoint&quot;/&gt; &lt;/aop:config&gt; 1234567&lt;!--配置通知类对象，在切面中引用--&gt; &lt;bean id=&quot;myBefore&quot; class=&quot;com.zbw.before.Before&quot;/&gt; &lt;bean id=&quot;myAfter&quot; class=&quot;com.zbw.after.After&quot;/&gt; &lt;bean id=&quot;demo1&quot; class=&quot;com.zbw.test.Demo1&quot;/&gt; &lt;bean id=&quot;demo2&quot; class=&quot;com.zbw.test2.Demo2&quot;/&gt;&lt;!--测试类Demo--&gt; &lt;bean id=&quot;demo&quot; class=&quot;com.zbw.test.Demo&quot;/&gt; 1234567public class After implements AfterReturningAdvice &#123; @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123; //Object o 切点方法的返回值 //Method method 切点方法对象 //Object[] objects 切点方法的参数 //Object o1 切点方法所在类的对象 AspectJ 每个通知不需要实现接口或类 配置 spring 配置文件是在&lt;aop:config&gt;的子标签&lt;aop:aspect&gt;中配置 注意： after就算切点报异常也会执行 类似finnaly after-returning 切点正常执行才会执行 执行顺序和配置顺序有关系。12345678910&lt;bean id=&quot;myAdvice&quot; class=&quot;com.zbw.myadvice.MyAdvice&quot;/&gt;&lt;aop:config&gt; &lt;aop:aspect ref=&quot;myAdvice&quot;&gt; &lt;aop:pointcut id=&quot;myPoint4&quot; expression=&quot;execution(* com.zbw.test.Demo.demo4())&quot;/&gt; &lt;aop:after method=&quot;myAfter2&quot; pointcut-ref=&quot;myPoint4&quot;/&gt; &lt;aop:after-returning method=&quot;myAfter&quot; pointcut-ref=&quot;myPoint4&quot;/&gt; &lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;myPoint4&quot;/&gt; &lt;aop:around method=&quot;myArround&quot; pointcut-ref=&quot;myPoint4&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 带参数的配置注意： 切点配置参数在execution外，用and连接，不能用&amp;&amp;，（xml的特殊符号）spring在转化成java后会转换成&amp;&amp;。 参数的名称必须都相同，包括通知类中的方法参数名称。12&lt;aop:pointcut id=&quot;myPoint4&quot; expression=&quot;execution(* com.zbw.test.Demo.demo5(String,int)) and args(name1,age1)&quot;/&gt;&lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;myPoint4&quot; arg-names=&quot;name1,age1&quot;/&gt; 配置异常通知(AspectJ) 只有当切点报异常才能触发异常通知 在 spring 中有 AspectJ 方式提供了异常通知的办法.如果希望通过 schema-base 实现需要按照特定的要求自己编写方法. 新建异常通知类 在spring配置文件中配置123456789101112&lt;!--异常通知类--&gt; &lt;bean id=&quot;myThrow&quot; class=&quot;com.zbw.myThrow.MyThrow&quot;/&gt;&lt;!--aspectJ配置异常通知--&gt; &lt;aop:config&gt;&lt;!--ref：引用异常通知对象--&gt; &lt;aop:aspect ref=&quot;myThrow&quot;&gt; &lt;aop:pointcut id=&quot;myPoint&quot; expression=&quot;execution(* com.zbw.test.Demo.demo1())&quot;/&gt;&lt;!--method：异常通知具体的方法名--&gt;&lt;!--throwing:异常对象名,必须和通知中方法参数名相同--&gt; &lt;aop:after-throwing method=&quot;myThrow&quot; pointcut-ref=&quot;myPoint&quot; throwing=&quot;e&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 配置异常通知(Schema-base)需要实现ThrowsAdvice接口 重写afterThrowing方法12345public class ScheamThrow implements ThrowsAdvice &#123; public void afterThrowing(Exception e)&#123; System.out.println(&quot;schema-base异常通知&quot;); &#125;&#125; spring配置中，和普通的schema-base配置相同 12345&lt;bean id=&quot;schemaThrow&quot; class=&quot;com.zbw.myThrow.ScheamThrow&quot;/&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPoint2&quot; expression=&quot;execution(* com.zbw.test.Demo.demo2())&quot;/&gt; &lt;aop:advisor advice-ref=&quot;schemaThrow&quot; pointcut-ref=&quot;myPoint2&quot;/&gt;&lt;/aop:config&gt; 环绕通知环绕通知：前置通知与后置通知放在了一起schema-base环绕通知类实现MethodInterceptor（方法拦截器）注意： 其中Object proceed = methodInvocation.proceed();对切点方法放行，并返回该方法的返回值，proceed。12345678910public class MyArround implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println(&quot;环绕-前置通知&quot;); System.out.println(methodInvocation.getMethod()); Object proceed = methodInvocation.proceed(); //对方法放行 System.out.println(&quot;环绕-后置通知&quot;); return proceed; &#125;&#125; spring中注解(基于AspectJ) 引入xmlns:context(需要有核心包context) 在需要被spring管理的类上 @Component@Component(“自定义名字”)如果没有定义，则该类名称首字母小写 在通知类即切面 @Aspect 在切点上 @Pointcut@Pointcut(&quot;execution(* com.zbw.test2.Demo2.demo22())&quot;) 在通知方法上 @对应的名称(所关联的切点)如：@Before(“com.zbw.test2.Demo2.demo22()”)","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://Zhangbingwu.github.io/tags/AOP/"}]},{"title":"Spring学习01","slug":"Spring学习01","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-04T07:20:38.717Z","comments":true,"path":"2019/08/03/Spring学习01/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/03/Spring学习01/","excerpt":"","text":"Spring 主要发明者:RodJohnson 轮子理论推崇者: 轮子理论:不用重复发明轮子. IT行业:直接使用写好的代码. Spring 框架宗旨:不重新发明技术,让原有技术使用起来更加方便. Spring 几大核心功能(重点) IoC/DI 控制反转/依赖注入 AOP 面向切面编程 声明式事务. Spring 框架 runtime test:spring 提供测试功能 CoreContainer:核心容器.Spring 启动最基本的条件. Beans:Spring 负责创建类对象并管理对象 Core: 核心类 Context: 上下文参数.获取外部资源或这管理注解等 SpEl:expression.jar AOP: 实现 aop 功能需要依赖 Aspects: 切面 AOP 依赖的包 DataAccess/Integration:spring 封装数据访问层相关内容 JDBC:Spring 对 JDBC 封装后的代码. ORM: 封装了持久层框架的代码.例如 Hibernate transactions:对应 spring-tx.jar,声明式事务使用. WEB:需要 spring 完成 web 相关功能时需要. 例如:由tomcat加载spring配置文件时需要有spring-web包 Spring 框架中重要概念 容器(Container):Spring 当作一个大容器. BeanFactory 接口.老版本. 新版本中 ApplicationContext 接口,是 BeanFactory 子接口.BeanFactory 的功能在 ApplicationContext 中都有. 从 Spring3 开始把 Spring 框架的功能拆分成多个 jar. Spring2 及以前就一个 jar 环境搭建 导入四个核心包和一个日志包corecontextbeanexpressioncommons-logging 全局配置文件 applicationContext.xml 文件名称和路径自定义. 记住 Spring 容器 ApplicationContext,applicationContext.xml 配置的信息最终存储到了 AppliationContext 容器中. spring 配置文件是基于 schema(模式)3.1 schema 文件扩展名.xsd3.2 把 schema 理解成 DTD 的升级版，但是比 DTD 具备更好的扩展性.3.3 每次引入一个 xsd 文件是一个 namespace(xmlns) 通过&lt;bean/&gt; 创建对象. 注意：默认配置文件被加载时创建对象 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- id 表示获取到对象标识 class 创建哪个类的对象 --&gt; &lt;bean id=&quot;peo&quot; class=&quot;com.zbw.pojo.People&quot;/&gt;&lt;/beans&gt; 可扩展性体现在，如果需要新的配置，只需要在xmlns声明，并把schema文件引入。 IoC名称 中文名称:控制反转 英文名称:(Inversion of Control) IoC 是什么? IoC 完成的事情原先由程序员主动通过 new 实例化对象事情,转交给 Spring 负责. 控制反转中控制指的是:控制类的对象. 控制反转中反转指的是转交给 Spring 负责. 让程序员与对象进行解耦，将类的实例化交给spring来控制。 IoC 最大的作用:解耦. 程序员不需要管理对象.解除了对象管理和程序员之间的耦合. 测试 在applicationContext.xml配置文件中添加： 12&lt;!-- id 表示获取到对象标识 class 创建哪个类的对象 --&gt;&lt;bean id=&quot;peo&quot; class=&quot;com.zbw.pojo.People&quot;/&gt; 测试代码： 1234567//加载xml文件，并在加载时完成所需对象的创建。ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//getBean(“&lt;bean&gt;标签id值”,返回值类型);如果没有第二个参数,默认是 ObjectPeople people = ac.getBean(&quot;peo&quot;, People.class);System.out.println(people); 还可以通过String[] strs = ac.getBeanDefinitionNames();获取到由spring现在管理的对象的数组。 spring中创建对象的三种方式1.通过构造方法创建 无参构造创建:默认情况. 有参构造创建:需要明确配置 需要在类中提供有参构造方法 在 applicationContext.xml 中设置调用哪个构造方法创建对象 注意：如果设定的条件匹配多个构造方法执行最后的构造方法 index: 参数的索引,从 0 开始 name: 参数名 type:类型(区分开关键字和封装类 int 和 Integer) ref:如果构造方法的参数是一个对象bean，用来引用对象。 如：com.zbw.pojo.Teacher配置代码： 1234&lt;bean id=&quot;peo&quot; class=&quot;com.zbw.pojo.People&quot;&gt; &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;java.lang.Integer&quot; value=&quot;123&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;王五&quot;/&gt;&lt;/bean&gt; 实例工厂创建 什么是实例工厂？就是先要创建工厂才能创建对象。 静态工厂创建 什么是静态工厂？能供直接创建对象。1234567&lt;!--动态工厂配置--&gt;&lt;!-- &lt;bean id=&quot;peopleFactory&quot; class=&quot;com.zbw.factory.PeopleFactory&quot;/&gt;--&gt;&lt;!-- &lt;bean id=&quot;peo2&quot; factory-bean=&quot;peopleFactory&quot; factory-method=&quot;newInstance&quot;/&gt;--&gt;&lt;!--静态工厂配置--&gt;&lt;!--其实就是类直接通过静态工厂创建--&gt; &lt;bean id=&quot;peo3&quot; class=&quot;com.zbw.factory.PeopleFactory&quot; factory-method=&quot;newInstance&quot;/&gt; 对对象的属性赋值1.在用有参构造创建对象时，对参数赋值。1234&lt;bean id=&quot;peo&quot; class=&quot;com.zbw.pojo.People&quot;&gt; &lt;constructor-arg index=&quot;0&quot; name=&quot;id&quot; type=&quot;java.lang.Integer&quot; value=&quot;123&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; name=&quot;name&quot; type=&quot;java.lang.String&quot; value=&quot;王五&quot;/&gt;&lt;/bean&gt; 2.设置注入(其通过对象的set方法实现，必须要有set方法) 属性为基本数据类型或String时&lt;property name=&quot;name&quot; value=&quot;李狗蛋&quot;/&gt; 对象属性为Set集合 123456&lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value &gt;1&lt;/value&gt; &lt;value &gt;2&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 对象属性为List注意：如果List中只有一个值&lt;property name=&quot;lists&quot; value=&quot;1,2,3&quot;/&gt;这样也是只有一个值。这点和数组相同。 对象属性为Map时 123456&lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;你&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;好&quot;/&gt; &lt;/map&gt;&lt;/property&gt; DI名称 中文名称:依赖注入 英文名称((Dependency Injection) DI 是什么? DI 和 IoC 是一样的 当一个类(A)中需要依赖另一个类()对象时,把 B 赋值给 A 的过程就叫做依赖注入. 代码体现12345678&lt;bean id=&quot;people&quot; class=&quot;com.zbw.pojo.People&quot;&gt; &lt;property name=&quot;desk&quot; ref=&quot;desk&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;desk&quot; class=&quot;com.zbw.pojo.Desk&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; people类中需要依赖desk，将desk类赋值给people的过程就是DI，依赖注入。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"IoC","slug":"IoC","permalink":"https://Zhangbingwu.github.io/tags/IoC/"},{"name":"DI","slug":"DI","permalink":"https://Zhangbingwu.github.io/tags/DI/"}]},{"title":"MyBatis学习03","slug":"MyBatis学习03","date":"2019-08-01T16:00:00.000Z","updated":"2019-08-03T12:26:10.869Z","comments":true,"path":"2019/08/02/MyBatis学习03/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/02/MyBatis学习03/","excerpt":"","text":"缓存什么是缓存？ 内存中的一块存储区域。 应用程序在获取数据时，会先去内存中查找（即缓存中有没有），如果没有就去数据库中获取，获取后并把数据放到缓存中。 缓存有什么作用？ 应用程序和数据库交互的过程是一个相对比较耗时的过程 缓存存在的意义:让应用程序减少对数据库的访问,提升程序运行效率 MyBatis中的缓存MyBatis中默认缓存开启。1.SqlSession缓存(一级缓存) 同一个 SqlSession 对象调用同一个&lt;select&gt;时,只有第一次访问数据库,第一次之后把查询结果缓存到 SqlSession 缓存区(内存)中 缓存的是 statement 对象.(简单记忆必须是用一个&lt;select&gt;),在myabtis时一个&lt;select&gt;对应一个 statement 对象 有效范围必须是同一个 SqlSession 对象 缓存的流程步骤一: 先去缓存区中找是否存在 statement 步骤二:返回结果 步骤三:如果没有缓存 statement 对象,去数据库获取数据 步骤四:数据库返回查询结果 步骤五:把查询结果放到对应的缓存区2.SqlSessionFactory缓存(二级缓存) 有效范围：同一个factory内的所有SqlSession都可以获取缓存内的数据。 使用时机：当数据频繁地被使用(查询)，但很少被修改。 注意：如果缓存中有所要查询的数据，而在这之前有语句修改了数据库中的数据，那么查询的数据就不正确。(脏读) 使用 在Mapper.xml中添加&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt;。如果不写 readOnly=”true”需要把实体类序列化。 当 SqlSession 对象 close()时或 commit()时会把 SqlSession 缓存的数据刷(flush)到 SqlSessionFactory 缓存区。 resultMap标签 和 resultMap属性作用 可以不依赖mybatis的AUTO MAPPING特性，即pojo中的属性名和数据库表的列名相同自动匹配，这样使得数据库中的列名和pojo中不同也可以。 实现多表查询 多表查询（N+1查询方式）通过select * from student查到了学生的信息，还想通过学生信息中tid(老师的id)，去select * from teacher where id=该学生的tid. N+1查询方式即先查询出一个表中的信息，再根据这个表中的信息去查询另一个表的数据。 使用 id标签 表的主键，如果联合主键则多个idproperty为类中的名字，column为数据库表的对应的列的名字。 result标签 映射其他列 association标签 关联单个对象时使用如下面例子，student关联了一个teacher collection标签 关联一个集合（内部多个对象） 代码StudentMapper.xml中代码1234567891011&lt;resultMap id=&quot;stu&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; select=&quot;com.zbw.mapper.TeacherMapper.selById&quot; column=&quot;tid&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll&quot; resultMap=&quot;stu&quot;&gt; select * from t_student&lt;/select&gt; TeacherMapper.xml中的代码 123&lt;select id=&quot;selById&quot; parameterType=&quot;int&quot; resultType=&quot;teacher&quot;&gt; select * from t_teacher where tid=#&#123;0&#125;&lt;/select&gt; 注意：如果pojo属性名和数据库列名相同，mybatis可以自动装配，但是一旦使用过一次，就不会自动装配，如：上面的tid被使用了，就必须&lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;其他的可以省略。 关联单个对象 联合查询方式1234567891011121314&lt;!--关联单个对象 联合查询方式--&gt;&lt;resultMap type=&quot;Student&quot; id=&quot;stuMap1&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot; &gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll1&quot; resultMap=&quot;stuMap1&quot;&gt; SELECT * FROM t_student t1 LEFT JOIN t_teacher t2 ON t1.tid=t2.tid&lt;/select&gt; 使用实现加载集合数据(联合查询方式) 直接通过联合查询方式，查询到了老师和学生的全部信息，不过会出现老师姓名重复。但是mybatis中会自动去掉重复的。 12345public class Teacher &#123; private int tid; private String tname; private List&lt;Student&gt; students;&#125; 12345678910111213&lt;resultMap id=&quot;myMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;tname&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selAll2&quot; resultMap=&quot;myMap&quot;&gt; SELECT * FROM t_teacher t1 LEFT JOIN t_student t2 ON t1.tid=t2.tid&lt;/select&gt; ofType 该集合的泛型 1对多，用集合的形式表现’多’，collection相当于一个有Student的集合，内部装配Student的属性。 N+1 方式和联合查询方式对比 N+1:需求不确定时. 联合查询:需求中确定查询时两个表一定都查询. N+1 缺点: 效率低 优点: 可以获得两个表的所有数据。 AUTO MAPPING特性結合SQL的別名完成多表查詢123&lt;select id=&quot;sel&quot; resultType=&quot;Student&quot; &gt; select t.tid `teacher.tid`,t.tname `teacher.tname`,s.id sid,s.name sname,age,s.tid from t_student s LEFT JOIN t_teacher t ON s.tid=t.tid&lt;/select&gt; 可以將數據庫的列名改為自己起的別名 t.tidteacher.tid將teacher表的tid列名改为teacher.tid，那么就会在Student中的teacher属性里找tid并赋值。 `t.tname `teacher.tname为teacher表中查到的tname起别名teacher.tname，将查到的值给Student里teacher属性的tname赋值。 注意：SQL中’.’是特殊符号，起别名不能使用. 要使用就要用反单引号 mybatis注解使用注解需要先在mybatis.xml全局配置中配置mappers标签。 package标签，接口所在的包。 mapper标签 class属性，具体到接口。 注解在Mapper接口中使用。 利用注解完成查询，不用在xml中进行装配，对于简单的增删改查更加方便。 1234567891011@Select(&quot;select * from t_teacher&quot;)List&lt;Teacher&gt; selAll();@Insert(&quot;insert into t_teacher values(default,#&#123;tname&#125;)&quot;)int ins(Teacher teacher);@Update(&quot;update t_teacher set tname=#&#123;tname&#125; where tid=#&#123;tid&#125;&quot;)int upd(Teacher teacher);@Delete(&quot;delete from t_teacher where tid=#&#123;0&#125;&quot;)int del(int i); 利用注解完成resultMap查询 N+1方式。StudentMapper接口中1234567891011@Results(value = &#123; @Result(id = true,property = &quot;sid&quot;,column = &quot;id&quot;), @Result(property = &quot;sname&quot;,column = &quot;name&quot;), @Result(property = &quot;age&quot;,column = &quot;age&quot;), @Result(property = &quot;tid&quot;,column = &quot;tid&quot;), @Result(property = &quot;teacher&quot;,column = &quot;tid&quot;,one = @One( select = &quot;com.zbw.mapper.TeacherMapper.selTeacher&quot; ))&#125;)@Select(&quot;select * from t_student&quot;)List&lt;Student&gt; selResultMap(); TeacherMapper接口中 12@Select(&quot;select * from t_teacher where tid=#&#123;tid&#125;&quot;)Teacher selTeacher(int tid); @Results() 相当于`&lt;resultMap&gt;` @Result() 相当于`&lt;id/&gt;`或`&lt;result/&gt;` @Result(id=true) 相当与`&lt;id/&gt;` @Many() 相当于`&lt;collection/&gt;` @One() 相当于`&lt;association/&gt;`mybatis运行原理在 MyBatis 运行开始时需要先通过 Resources 加载全局配置文件.下面需要实例化 SqlSessionFactoryBuilder 构建器.帮助 SqlSessionFactory 接口实现类 DefaultSqlSessionFactory.在实例化 DefaultSqlSessionFactory 之前需要先创建 XmlConfigBuilder解析全局配置文件流,并把解析结果存放在 Configuration 中.之后把Configuratin 传递给 DefaultSqlSessionFactory.到此 SqlSessionFactory 工厂创建成功.由 SqlSessionFactory 工厂创建 SqlSession.每次创建 SqlSession 时,都需要由 TransactionFactory 创建一个Transaction对象,同时还需要创建 SqlSession 的执行器 Excutor,最后实例化DefaultSqlSession,传递给 SqlSession 接口.根据项目需求使用 SqlSession 接口中的 API 完成具体的事务操作.如果事务执行失败,需要进行 rollback 回滚事务.如果事务执行成功提交给数据库.关闭 SqlSession","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://Zhangbingwu.github.io/tags/缓存/"},{"name":"mybatis注释","slug":"mybatis注释","permalink":"https://Zhangbingwu.github.io/tags/mybatis注释/"}]},{"title":"MyBatis学习02","slug":"MyBatis学习02","date":"2019-07-31T16:00:00.000Z","updated":"2019-08-01T16:44:58.056Z","comments":true,"path":"2019/08/01/MyBatis学习02/","link":"","permalink":"https://Zhangbingwu.github.io/2019/08/01/MyBatis学习02/","excerpt":"","text":"getMapper()原理这是源码中的注解，该抽象方法返回一个绑定了SqlSession的mapper对象。 123456/** * Retrieves a mapper. * @param &lt;T&gt; the mapper type * @param type Mapper interface class * @return a mapper bound to this SqlSession */ 内部使用的时JDK的动态代理模式，为Mapper接口生成一个proxy代理类，该类中的方法使用反射，映射了一个Mapper的实现类，该实现类不因getMapper的存在而存在，而是在使用Mapper.xml时，就有了这个实现类，来实现jdbc查询。 使用 在Mapper.xml所在的包下建立一个Mapper接口，注意接口名必须和Mapper.xml相同。 在mybatis.xml全局配置中配置。 1234&lt;mappers&gt;&lt;!--使用getMapper()时使用,确定接口所在的包--&gt; &lt;package name=&quot;com.zbw.mapper&quot;/&gt;&lt;/mappers&gt; 接口中定义方法，注意：方法名，返回值类型必须和xml文件中相同。 使用 12StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);List&lt;Student&gt; students = studentMapper.selAll(); 作用 简化了书写，提高了开发效率。 最主要的可以直接传入多个参数，而不像原来使用map完成多个参数。 多个参数1.接口中直接传入参数List&lt;Student&gt; selCon(int id,String name); 对应的xml中 123&lt;select id=&quot;selCon&quot; resultType=&quot;Student&quot;&gt; &lt;!--有多个参数可以省略paramType--&gt; select * from t_student where id=#&#123;0&#125; or name=#&#123;1&#125;;&lt;/select&gt; #{}中为 0 1 2 或 param1 param2 param3 2.使用注解1234567/** * 利用mybatis注解@param，实现原理：mybatis将参数转化为一个map，其中@param中的为map的key，int id的实参为map的value。 * @param id * @param name * @return */List&lt;Student&gt; selCon(@Param(&quot;id&quot;) int id, @Param(&quot;name&quot;) String name); 对应的xml中123&lt;select id=&quot;selCon&quot; resultType=&quot;Student&quot;&gt; &lt;!--有多个参数可以省略paramType--&gt; select * from t_student where id=#&#123;id&#125; or name=#&#123;name&#125;;&lt;/select&gt; 动态SQLOGNL OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。 MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素 无需其他的特殊符号 概念 根据不同的条件需要执行不同的 SQL 命令.称为动态 SQL MyBatis 中动态 SQL 在 mapper.xml 中添加逻辑判断等. 代码Mapper.xml映射文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!--动态sql if标签--&gt; &lt;select id=&quot;selAct&quot; resultType=&quot;Student&quot;&gt; select * from t_student where 1=1 &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null and name!=&apos;&apos;&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&apos;&apos;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/select&gt; &lt;!--set标签--&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Student&quot;&gt; update t_student &lt;set&gt; id=#&#123;id&#125;, &lt;if test=&quot;name!=null and name!=&apos;&apos;&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&apos;&apos;&quot;&gt; age=#&#123;age&#125;, &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; &lt;!--where标签--&gt; &lt;select id=&quot;selAct&quot; resultType=&quot;Student&quot;&gt; select * from t_student &lt;where&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name!=null and name!=&apos;&apos;&quot;&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&apos;&apos;&quot;&gt; and age=#&#123;age&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;!--choose when otherwise标签--&gt; &lt;select id=&quot;selCho&quot; resultType=&quot;Student&quot;&gt; select * from t_student &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#&#123;id&#125; &lt;/when&gt; &lt;when test=&quot;name!=null and name!=&apos;&apos;&quot;&gt; and name=#&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt; and id=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;!--trim标签--&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Student&quot;&gt; update t_student &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; id=#&#123;id&#125;, &lt;if test=&quot;name!=null and name!=&apos;&apos;&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age!=null and age!=&apos;&apos;&quot;&gt; age=#&#123;age&#125;, &lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt;&lt;!--bind标签--&gt; &lt;select id=&quot;SelLike&quot; resultType=&quot;Student&quot; &gt; select * from t_student &lt;where&gt; &lt;bind name=&quot;name&quot; value=&quot;&apos;%&apos;+name+&apos;%&apos;&quot;/&gt; name like #&#123;name&#125; &lt;/where&gt; &lt;/select&gt;&lt;!--foreach标签--&gt; &lt;select id=&quot;selIn&quot; resultType=&quot;Student&quot;&gt; select * from t_student where age in &lt;foreach collection=&quot;list&quot; item=&quot;age&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;age&#125; &lt;/foreach&gt; &lt;/select&gt; 小结 where,choose标签，都是如果判断条件为真，执行时会去掉sql语句的开头的and。 trim标签 可以自由的添加或去掉，注意是开始和结束位置。prefix 在前面添加内容prefixOverrides 去掉前面内容suffix 在后面添加内容suffixOverrieds 去掉后面内容注意：执行顺序去掉内容后添加内容。 bind 标签作用:给参数重新赋值场景:模糊查询在原内容前或后添加内容&lt;bind name=&quot;name&quot; value=&quot;&#39;%&#39;+name+&#39;%&#39;&quot;/&gt; foreach 标签循环参数内容,还具备在内容的前后添加内容,还具备添加分隔符功能. 适用场景: in 查询中 批量新增中(mybatis中foreach 效率比较低) 注意：如果希望批量新增openSession()必须指定factory.openSession(ExecutorType.BATCH);底层 JDBC 的 PreparedStatement.addBatch(); sql和include标签某些 SQL 片段如果希望复用,可以使用&lt;sql&gt;定义这个片段 123&lt;sql id=&quot;mysql&quot;&gt; id,name,age &lt;/sql&gt; 在&lt;select&gt;或&lt;delete&gt;或&lt;update&gt;或&lt;insert&gt;中使用&lt;include&gt;引用 1234&lt;select id=&quot;&quot;&gt; select &lt;include refid=&quot;mysql&quot;&gt;&lt;/include&gt; from table&lt;/select&gt; OpenSessionInViewThreadLocal 线程容器,给线程绑定一个 Object 内容,只要线程不变,可以随时取出. 改变线程,无法取出内容. 对SqlSession获取的封装 factory实例化的过程是一个比较耗费性能的过程。 从Filter到Servlet是一个线程，（Servlet相当于Filter的一个方法调用），从Servlet调用Service也是一个线程，因此使用ThreadLocal.set()对生产的SqlSession进行存储，同一线程内可以进行获取，提高了开发效率和性能。 MyBatisUtil代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zbw.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtil &#123; private static SqlSessionFactory factory = null; private static ThreadLocal&lt;SqlSession&gt; tl = new ThreadLocal(); static &#123; try &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); factory = new SqlSessionFactoryBuilder().build(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取一个SqlSession对象 * @return SqlSession对象 */ public static SqlSession getSqlSession()&#123; SqlSession sqlSession = tl.get(); if(sqlSession==null)&#123; //这里有点像单例模式，对象存在就返回该对象，不存在就创建 sqlSession = factory.openSession(); tl.set(sqlSession); &#125; return sqlSession; &#125; /** * 关闭SqlSession */ public static void closeSqlSession()&#123; if(tl.get()!=null)&#123; tl.get().commit(); tl.get().close(); &#125; tl.set(null); &#125;&#125;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"OpenSessionInView","slug":"OpenSessionInView","permalink":"https://Zhangbingwu.github.io/tags/OpenSessionInView/"},{"name":"动态SQL","slug":"动态SQL","permalink":"https://Zhangbingwu.github.io/tags/动态SQL/"}]},{"title":"TCP/IP学习","slug":"TCPIP学习","date":"2019-07-30T07:30:18.627Z","updated":"2019-07-30T07:30:18.627Z","comments":true,"path":"2019/07/30/TCPIP学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/30/TCPIP学习/","excerpt":"","text":"TCP/IP什么是TCP/IP? 是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及http、ftp、pop3协议等等。 作用定义计算机交流语言，使得计算机之间可以自由交流。 TCP/IP协议分层 TCP/IP三次握手和四次挥手 参考至 三次握手术语 SYNSYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。 ACKACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。 全双工（Full Duplex）全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。单工就是在只允许甲方向乙方传送信息，而乙方不能向甲方传送 。 步骤： 第一次：client向server发送SYN握手信号请求建立连接。 第二次：server接收后回复数据包（包括SYN，ACK，ack,seq）。 第三次：client接收后进行验证，如果正确将数据包返回给server，server确认后无误双方建立连接。 A和给B打电话。 拨通 A说喂，我是A，我找B。 B说哦，我是B，你说。 四次挥手步骤 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 client发送FIN关闭与server之间的数据传送。 server接收后发送ACK确认信号到client。 server发送一个FIN到client，关闭之间的数据传送 client收到FIN后，进入TIME_WAIT状态，并发送一个ACK给server，完成四次挥手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://Zhangbingwu.github.io/tags/TCP-IP/"}]},{"title":"MyBatis学习01","slug":"MyBatis学习01","date":"2019-07-29T16:00:00.000Z","updated":"2019-08-14T13:07:09.350Z","comments":true,"path":"2019/07/30/MyBatis学习01/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/30/MyBatis学习01/","excerpt":"","text":"MyBatis什么是MyBatis? MyBatis是数据库访问层框架，简化Dao层，提高开发效率。 框架和类库的差别? 类库：类似名言警句，直接拿来用。 框架：类似填空题，是软件开发的半成品。 使用 环境搭建 导入mybatis的jar包,和依赖jar包。 在src下建立mybatis.xml，全局环境配置，作用数据库的连接 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--可以有多个环境，default引用当前使用的--&gt;&lt;environments default=&quot;development&quot;&gt;&lt;!--声明可以使用的环境--&gt; &lt;environment id=&quot;development&quot;&gt;&lt;!--使用原生JDBC事务--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!-property的那么属性必须按照要求--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/库名?serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;数据库用户名&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;数据库密码&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 使UserMapper.xml配置生成的sql查询方法连接数据库 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/zbw/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; transactionManager标签的type属性可取值： JDBC，事务管理使用原生的JDBC管理模式。 MANAGED，将事务管理转交给其他容器，原生JDBC事务管理的setAutoMapping(false),设置为不自动提交。 dataSource标签type属性： POOLED，使用数据库连接池。 UNPOOLED，不使用数据库连接池，相当于直接使用JDBC。 JNDI：(java naming and directory interface)java命名目录接口技术，可以让java使用其他的如c语言编写的代码。 mybatis建议数据访问层命名mapper包,包下建立UserMapper.xml文件。作用：配置mybatis帮你生成一个a.b.selAll的方法，来执行你指定的sql语句。12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace:理解成实现类的全限定路径&quot;包名+类名&quot;--&gt;&lt;mapper namespace=&quot;a.b&quot;&gt;&lt;!-- id:方法名 paramType:方法的参数类型 resultType:方法的返回值类型。 如果方法的返回值类型是List，在resultType中写List的泛型， 因为mybatis对jdbc封装，一行一行读取数据。--&gt; &lt;select id=&quot;selAll&quot; resultType=&quot;com.zbw.pojo.User&quot;&gt; select * from users; &lt;/select&gt;&lt;/mapper&gt; 数据库连接池 Tomcat JDBC pool状态Active：当前连接对象被应用程序使用中Idle：空闲状态，等待应用程序使用 使用 在META-INF下创建context.xml。IDEA context.xml的配置内部参数： 1.JDBC连接 driverClassName=&quot;&quot; url=&quot;&quot; username=&quot;&quot; password=&quot;&quot; 2.数据库连接池的管理 maxActice=&quot;&quot; 最大正在使用的连接数量 maxIdle=&quot;&quot; 最大正在空闲的连接池内对象的数量 name=&quot;&quot; 该连接池的名称 auth=&quot;Container&quot; 数据库连接池交由应用程序还是服务器管理 maxWait=&quot;10000&quot; 最大等待时间10s type=&quot;javax.sql.DataSource&quot; 在java中通过name属性取到的数据库连接池，在java中的类型是什么123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt; &lt;Resource driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/sorm?serverTimezone=GMT&quot; username=&quot;root&quot; password=&quot;root&quot; maxActice=&quot;50&quot; maxIdle=&quot;20&quot; name=&quot;test&quot; auth=&quot;Container&quot; maxWait=&quot;10000&quot; type=&quot;javax.sql.DataSource&quot; /&gt;&lt;/Context&gt; 使用JNDI测试数据库连接池首先，既然设置了交由tomcat服务器管理，因此只有将项目发布至tomcat才能使用连接池。 12345Context context = new InitialContext(); //获取Context.xml对象DataSource ds = (DataSource) context.lookup(&quot;java:comp/env/test&quot;);//java:comp/env/固定字符串，完全实体，在context中寻找test连接池，返回DataSourceconn = ds.getConnection();//通过DataSource工厂获取连接。 DataSource 该工厂用于提供到此 DataSource 对象所表示的物理数据源的连接。作为 DriverManager 工具的替代项，DataSource 对象是获取连接的首选方法。实现 DataSource 接口的对象通常在基于 Java Naming and Directory Interface (JNDI) API 的命名服务中注册。 DataSource 接口由驱动程序供应商实现。共有三种类型的实现：基本实现 - 生成标准的 Connection 对象连接池实现 - 生成自动参与连接池的 Connection 对象。此实现与中间层连接池管理器一起使用。分布式事务实现 - 生成一个 Connection 对象，该对象可用于分布式事务，大多数情况下总是参与连接池。此实现与中间层事务管理器一起使用，大多数情况下总是与连接池管理器一起使用。 三种查询方法statment为对应Mapper.xml中select的id。 selectList(String statment) 适用于 查询结果都需要遍历。 Mapper.xml中select标签的resultType（查询返回值类型）应该是集合中存储的对象，即集合的泛型，因为查询是一行一行的查，而每一行的数据就是一个对象。 selectOne(String statment) 返回值 Object 适用于 查询的是一行数据，或者一个变量。 如：select count(*) from table; 变量。 Mapper.xml中select标签的resultType（查询返回值类型）应该是内建的类型别名，帮助文档XML映射配置文件中typeAliases。 selectMap(String statment,String mapKey) 返回值Map(Object,OBject) 适用于 需求需要通过某一列的值快速查找这行数据的需求。 Mapper.xml中select标签的resultType（查询返回值类型）应该是Map中存储的值的类型。 把数据库中某一列的值当作map的key 查询参数 select标签中 paramType来控制查询方法中的参数类型 sqlSession.selectList() 和 selectOne() 的第二个参数 是传入查询中参数的具体值。 #{}和${}的区别 #{}获取参数的内容，支持索引获取，并且SQL使用?占位符。 ${}SQL是字符串拼接,不使用?占位符,默认找里面内容的get/set方法,如果是数字,就是一个数字。 #{} 注意： 当只有一个参数时(基本数据类型或String)，#{}里面写什么都行。 #{0} #{param1} 都表示第一个参数 paramType为对象123456//这里 创建一个Student实例 并且id为1，第二个参数为这个Student实例，//#&#123;id&#125; $&#123;id&#125; parameterType=&quot;com.zbw.pojo.Student&quot; 这里是通过传入参数Student实例的id的getter方法获取。 Student student =new Student(); student.setId(1); Student s = sqlSession.selectOne(&quot;com.zbw.mapper.StudentMapper.selById2&quot;,student); System.out.println(s); paramType为map（Map）1234567//多个参数 使用对象或map//parameterType=&quot;map&quot; id=#&#123;id&#125; or name=#&#123;name&#125;Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;id&quot;,2);map.put(&quot;name&quot;,&quot;张三&quot;);List&lt;Student&gt; list = sqlSession.selectList(&quot;com.zbw.mapper.StudentMapper.selById3&quot;,map);System.out.println(list); 分页查询SQL语句复习1234567#从第五行算起 往后找两行，这里是索引，从0开始算起。SELECT * FROM t_student LIMIT 4,2#一页显示几个:pageSize 显示第几页:pageNumber#pageSize*(pageNumber-1) = 第几页 第一个参数#pageSize 第二个参数#一页显示两个，显示第三页SELECT * FROM t_student LIMIT 4,2 分页查询1234567891011//注意：sql语法不能在特殊符号（关键字）前后进行数学运算，需要提前算好。//一页显示几个 int pageSize = 4;//显示第几页int pageNumber = 2;int pageStart = pageSize*(pageNumber-1);Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;pageSize&quot;,pageSize);map.put(&quot;pageStart&quot;,pageStart);List&lt;Student&gt; list = sqlSession.selectList(&quot;com.zbw.mapper.StudentMapper.selByLim&quot;,map);System.out.println(list); MyBatis 实现新增 概念复习1.1 功能:从应用程序角度出发,软件具有哪些功能.1.2 业务:完成功能时的逻辑.对应 Service 中一个方法1.3 事务:从数据库角度出发,完成业务时需要执行的 SQL 集合,统称一个事务.1.3.1 事务回滚.如果在一个事务中某个 SQL 执行事务,希望回归到事务的原点,保证数据库数据的完整性. 在 mybatis 中默认是关闭了 JDBC 的自动提交功能2.1 每一个 SqlSession 默认都是不自动提交事务.2.2session.commit()提交事务.2.3openSession(true);自动提交.setAutoCommit(true); mybatis 底层是对 JDBC 的封装.3.1JDBC 中 executeUpdate()执行新增,删除,修改的 SQL.返回值 int,表示受影响的行数.3.2mybatis 中&lt;insert&gt;&lt;delete&gt;&lt;update&gt;标签没有 resultType 属性,认为返回值都是 int 在 openSession()时 Mybatis 会创建 SqlSession 时同时创建一个Transaction(事务对象),同时 autoCommit 都为 false4.1 如果出现异常,应该 session.rollback()回滚事务. mybatis 别名内置别名 基本类型之前加_如:int _int 对象全部小写如:HashMap hashmap 自己设置别名类别名 mybatis.xml全局配置中 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.zbw.pojo.Student&quot; alias=&quot;stu&quot;/&gt;&lt;/typeAliases&gt; 在mapper.xml中 resultType中可以简化为直接写自己定义的别名stu 包别名 mybatis.xml全局配置中 123&lt;typeAliases&gt; &lt;package name=&quot;com.zbw.pojo&quot;/&gt;&lt;/typeAliases&gt; 在mapper.xml中 resultType中可以简化为直接写com.zbw.pojo包下的类名","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Zhangbingwu.github.io/tags/MyBatis/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://Zhangbingwu.github.io/tags/数据库连接池/"}]},{"title":"Servlet学习05","slug":"Servlet学习05","date":"2019-07-27T16:00:00.000Z","updated":"2019-07-28T12:11:32.298Z","comments":true,"path":"2019/07/28/Servlet学习05/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/28/Servlet学习05/","excerpt":"","text":"Filter过滤器作用 对服务器接收的请求资源和响应给浏览器的资源进行管理。 保护Servlet。 使用步骤 实现javax.servlet.Filter 配置web.xml，类似servlet的配置1./* 过滤所有请求。2.*.do 对所有以.do结尾的请求过滤，一般是来进行模块拦截处理。3.具体的servlet的url-pattern过滤顺序从大到小，在符合条件的情况下，被大的过滤后进入小的过滤。 init() 在服务器启动时初始化。 doFilter()filterChain.doFilter(servletRequest,servletResponse);对请求放行。放行的请求抵达servlet,执行完servlet又会回到filterChain.doFilter()，才算执行完doFilter() ，类似方法的调用。 destroy() 服务器关闭时销毁 注意： 导包正确 javax.Servlet.Filter doFilter(servletRequest,servletResponse),注意参数不是HttpServletRequest,是其父类，可以(HttpServletRequest)servletRequest转型。 Listener监听器作用 对作用域对象进行监听，有点像事件机制。 对请求的监听 1.请求的创建和销毁需要实现ServletRequestListener requestInitialized() 初始化请求时 requestDestroyed() 请求销毁时 2.请求内容的更改需要实现ServletRequestAttributeListener attributeAdded() 新增的请求内容 attributeRemoved() 被移除的请求内容 attributeReplaced() 注意：保存的是被替换的请求的内容 srae.getName()srae.getValue() Session的监听 接口：HttpSessionListener 接口：HttpSessionAttributeListener application的监听 接口：ServletContextListener 接口：ServletContextAttributeListener","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Filter","slug":"Filter","permalink":"https://Zhangbingwu.github.io/tags/Filter/"}]},{"title":"Servlet 3.0 新特性","slug":"Servlet 3.0 新特性","date":"2019-07-27T16:00:00.000Z","updated":"2019-07-28T11:18:42.345Z","comments":true,"path":"2019/07/28/Servlet 3.0 新特性/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/28/Servlet 3.0 新特性/","excerpt":"","text":"Servlet 3.0 新特性参考至 1.Servlet异步处理支持 Servlet 3.0 之前，一个普通 Servlet 的主要工作流程大致如下：首先，Servlet 接收到请求之后，可能需要对请求携带的数据进行一些预处理；接着，调用业务接口的某些方法，以完成业务处理；最后，根据处理的结果提交响应，Servlet 线程结束。其中第二步的业务处理通常是最耗时的，这主要体现在数据库操作，以及其它的跨网络调用等，在此过程中，Servlet 线程一直处于阻塞状态，直到业务方法执行完毕。在处理业务的过程中，Servlet 资源一直被占用而得不到释放，对于并发较大的应用，这有可能造成性能的瓶颈。对此，在以前通常是采用私有解决方案来提前结束 Servlet 线程，并及时释放资源。 Servlet 3.0 针对这个问题做了开创性的工作，现在通过使用 Servlet 3.0 的异步处理支持，之前的 Servlet 处理流程可以调整为如下的过程：首先，Servlet 接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；接着，Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。如此一来， Servlet 线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回。 异步处理特性可以应用于 Servlet 和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet 和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下的方式启用： 开启异步支持 3.0注解也可以使用@WebServlet(name = &quot;Servlet&quot;,urlPatterns = &quot;/ser&quot;,asyncSupported = true) 对于使用传统的部署描述文件 (web.xml) 配置 Servlet 和过滤器的情况，Servlet 3.0 为 &lt;servlet&gt; 和 &lt;filter&gt; 标签增加了 &lt;async-supported&gt; 子标签，该标签的默认取值为 false，要启用异步处理支持，则将其设为 true 即可。以 Servlet 为例，其配置方式如下所示：12345&lt;servlet&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;footmark.servlet.Demo Servlet&lt;/servlet-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; 2.注解支持 1.@WebServlet name String 指定 Servlet 的 name 属性，等价于 &lt;servlet-name&gt;。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用。urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于 &lt;url-pattern&gt; 标签。 loadOnStartup int 指定 Servlet 的加载顺序，等价于 &lt;load-on-startup&gt; 标签。 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于 &lt;init-param&gt; 标签。 2.@WebInitParam name String 指定参数的名字，等价于 &lt;param-name&gt;。 value String 指定参数的值，等价于 &lt;param-value&gt;。 3.@WebFilter filterName String 指定过滤器的 name 属性，等价于 &lt;filter-name&gt; value String[] 该属性等价于 urlPatterns 属性。但是两者不应该同时使用。 urlPatterns String[] 指定一组过滤器的 URL 匹配模式。等价于 &lt;url-pattern&gt; 标签。 servletNames String[] 指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 &lt;servlet-name&gt; 的取值。 4.@WebListener value String 可不选 该监听器的描述信息。 5.@MultipartConfig辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持。该注解标注在 Servlet 上面，以表示该 Servlet 希望处理的请求的 MIME 类型(Multipurpose Internet Mail Extensions多用途互联网邮件扩展)是 multipart/form-data(指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思)。 HttpServletRequest 对文件上传的支持 Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件： Part getPart(String name) Collection getParts()前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：123Part photo = request.getPart(&quot;photo&quot;); photo.write(&quot;/tmp/photo.jpg&quot;); // 可以将两行代码简化为 request.getPart(&quot;photo&quot;).write(&quot;/tmp/photo.jpg&quot;) 一行。","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"Servlet学习04","slug":"Servlet学习04","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T15:19:17.984Z","comments":true,"path":"2019/07/27/Servlet学习04/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/27/Servlet学习04/","excerpt":"","text":"EL表达式EL表达式的作用 可以获取servlet四个作用域中的数据 request session pageContext application 注意：不是获取servlet流转的数据，而是四个作用域中的数据。 使用 ${表达式}如果是请求参数 ${param.键名} ${paramValues.键名} 返回数组，例如爱好。 如果是setAttribute()存储的数据 ${键名}存储的式字符串返回字符串存储的对象返回对象 ${键名.属性名} 直接返回对象的属性值 ${list} 如果是List集合,返回数组${list[0]} 集合中第一个对象。 ${map.map的键名} 如果是Map集合，返回该map键名对应的值${map.get(键名)} EL表达式作用域查找顺序 如果请求数据中，不同作用域键名相同。EL表达式查找哪个？ 默认顺序：作用域从小到大找，小的里面没找到再去大的里面找，找到了后就不再继续查找。作用域从小到大：pageContext（当前页面）-&gt;request（一次请求）-&gt;session（一次会话）-&gt;application（服务器启动到关闭）注意：从小到大依次找。 指定顺序：想要EL表达式去指定的作用域查找怎么办？${pageScope.键名}${requestScope.键名}${sessionScope.键名}${applicationScope.键名} EL表达式还可以做简单的逻辑运算 加减乘除取余${1+2} — 3 判断${1&gt;2} — true${1==1} — true${1!=2} — true${1&lt;=1} — true 三目运算${sex==1?”男”:”女”} 注意： EL表达式中’+’号只有运算的作用，没有字符串连接作用,会报错。 ${1+”2”} 会将”2”转化为2，继续运算。 EL获取请求头数据和Cookie数据请求头数据 ${header} 取出所有请求头数据 ${header[“键名”]} 取出指定键名的请求头数据 ${headerValues[“键名”]} 取出指定键名(同键不同值)的请求头数组${headerValues[“键名”][0]} Cookie数据 ${cookie} 取出所有Cookie数据 ${cookie.键名} 获取这个Cookie对象1&#123;JSESSIONID=javax.servlet.http.Cookie@383b7293, Idea-51c8b0a1=javax.servlet.http.Cookie@2711011c&#125; 1JSESSIONID=B433435550B2EF7337CFFF3A6B21E581 JSTL标签使用之前 导jstl的jar包下载impl 设置page指令&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; jstl基本标签 &lt;c:out value=&quot;&quot; default=&quot;&quot; &gt;&lt;/c:out&gt;结合EL表达式&lt;c:out value=&quot;${str2}&quot; default=&quot;天天心情好&quot;&gt;&lt;/c:out&gt;作用：直接输出，如果为空，则输出默认值。 &lt;c:set var=&quot;键名&quot; value=&quot;键值&quot; scope=&quot;存储作用域&quot;&gt;&lt;/c:set&gt;类似于 作用域对象.setAttribute(“”,””)，默认存放在pageContext作用域 12&lt;c:set var=&quot;str&quot; value=&quot;我不好&quot; scope=&quot;request&quot;&gt;&lt;/c:set&gt;&lt;c:out value=&quot;$&#123;requestScope.str&#125;&quot;&gt;&lt;/c:out&gt; &lt;c:remove var=&quot;键名&quot; scope=&quot;存储作用域&quot;&gt;&lt;/c:remove&gt;类似于作用域对象.removeAttribute()注意：如果不指定作用域，会将四个作用域中符和键名的数据都删除。 jstl逻辑标签 单分支1234&lt;c:set var=&quot;score&quot; value=&quot;90&quot;&gt;&lt;/c:set&gt;&lt;c:if test=&quot;$&#123;score&gt;80&#125;&quot;&gt; &lt;u&gt;干得漂亮！&lt;/u&gt; &lt;/c:if&gt; 配合EL逻辑表达式，因此表达式值必须是四个作用域中的。 多分枝1234567891011&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;fruit==&apos;apple&apos;&#125;&quot;&gt; &lt;b&gt;苹果！&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;fruit==&apos;banana&apos;&#125;&quot;&gt; &lt;i&gt;香蕉！&lt;/i&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;b&gt;蔬菜！&lt;/b&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; jstl的循环标签(常用) 常量循环12345&lt;c:forEach begin=&quot;0&quot; end=&quot;3&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt; &lt;c:if test=&quot;$&#123;vs.index&lt;=2&#125;&quot;&gt; 哥哥，你真猛！---$&#123;vs.index&#125;---$&#123;vs.count&#125;&lt;br&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; step:步数，默认为1.varStatus:在作用域中存储了每一次循环的数据(角标，次数，是否第一次循环，是否最后一次循环) 动态循环List集合：123&lt;c:forEach items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;v&quot;&gt; $&#123;v&#125;&lt;br&gt; &lt;/c:forEach&gt; Map集合： 123&lt;c:forEach items=&quot;$&#123;requestScope.map&#125;&quot; var=&quot;m&quot;&gt; $&#123;m&#125;---$&#123;m.key&#125;---$&#123;m.value&#125;&lt;br&gt; &lt;/c:forEach&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"},{"name":"EL表达式","slug":"EL表达式","permalink":"https://Zhangbingwu.github.io/tags/EL表达式/"},{"name":"JSTL标签","slug":"JSTL标签","permalink":"https://Zhangbingwu.github.io/tags/JSTL标签/"}]},{"title":"Servlet学习03","slug":"Servlet学习03","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-06T12:42:49.896Z","comments":true,"path":"2019/07/26/Servlet学习03/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/26/Servlet学习03/","excerpt":"","text":"Ajax学习标准请求响应时浏览器的动作(同步操作)浏览器请求什么资源,跟随显示什么资源什么是Ajax? 局部刷新技术Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），用来在当前页面内响应不同的请求内容。 Ajax并非一种新的技术，而是几种原有技术的结合体，是浏览器端的技术。 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 Ajax运行原理 参考至 在JS中，通过XMLHttpRequest对象向服务器异步发送请求，获取响应数据，通过JS操作文档结构，达到更新数据的展示。 Ajax采用异步请求，虽然同步效率高于异步，但是通过异步请求，不会阻塞用户，可以达到无刷新更新数据的效果。 Ajax的使用 1.获取Ajax对象 因为浏览器版本的问题判断。 2.重写onreadystatechange函数 判断Ajax状态码判断响应状态码 获取响应内容 处理响应内容(操作文档结构) 3.发送请求 示例1234567//创建Ajax引擎对象 var xmlHttp; if(window.XMLHttpRequest)&#123; //火狐等 xmlHttp = new XMLHttpRequest(); &#125;else if(window.ActiveXObject)&#123; //IE低版本 xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlHttp.onreadystatechange = function () {} //重写onreadystatechange函数 xmlHttp.readyState Ajax状态码(0,1,2,3,4)0:建立了ajax对象，但是还未初始化1:ajax对象创建 open()调用2:send()调用3:请求成功发送，正在接收数据4:接收数据成功 xmlHttp.status 响应状态码12xmlHttp.open(&quot;get&quot;,&quot;a&quot;,true); // (&quot;请求方式&quot;,&quot;uri&quot;,&quot;是否开启异步&quot;)xmlHttp.send(null); //post请求的话，用来发送请求参数。 Ajax的异步和同步默认为true：开启异步 同步：Ajax发送请求后，等待数据接收后，再继续执行接下来的代码。 异步：Ajax发送请求后，开辟一个线程去等待接收，与此同时继续执行接下来的代码。 Ajax请求方式 get方式 12xmlHttp.open(&quot;get&quot;,&quot;a?name=杨二&amp;pwd=321&quot;,true);xmlHttp.send(null); post方式 123xmlHttp.open(&quot;post&quot;,&quot;a&quot;,true);xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlHttp.send(&quot;name=张三&amp;pwd=123&quot;); post方式必须要有，设置参数类型是键值对。xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”); Ajax响应JSON 在处理Ajax请求，响应数据的时候，如果数据是对象，或者装有对象的集合。 分析 要将对象完整的传输，可以用js的对象存储已有的对象 json格式：响应数据：var obj={“name”:”zhangsan”,”pwd”:”123”} 在js中使用Global.eval()方法，检查并执行内部代码，Global可以省略，js中便创建了相同内容的对象。 但是后台不应该规定对象名，所以直接响应： {“name”:”zhangsan”,”pwd”:”123”} 在js中eval(“var obj2=”+ajax对象.responseText); 为了方便，不用自己拼接字符串，可以使用Gson可以将对象，集合自动转为json格式。resp.getWriter().write(new Gson().toJson(h)); List的话 Gson会转为[{},{},{}···] 这样的数组 如果服务器返回数据是从表中取出.为了方便客户端操作返回的数据,服务器端返回的数据设置成json 客户端把 json 当作对象或数组操作. json:数据格式.JsonObject:json 对象,理解成 java 中对象 {“key”:value,”key”:value}JsonArray:json 数组 [{“key”:value,”key”:value},{}] XML 接收ajax请求的servlet必须设置响应编码格式。resp.setContentType(&quot;text/xml;charset=utf-8&quot;); ajax接收时。12var doc = xmlHttp.responseXML;alert(doc.getElementsByTagName(&quot;name&quot;)[0].innerHTML); jQuery封装Ajax第一层 $.ajax({ 属性名:值,属性名:值})是 jquery 中功能最全的.代码写起来相对最麻烦的.url:请求的地址data:请求时要发送的数据，json格式。dataType:预期服务器返回的数据类型。 html,json,xml,Script,text,jsonperror:请求失败所执行的功能（函数）success:请求成功所执行的功能（函数）type:请求方式 示例123456789101112$.ajax(&#123; url:&quot;&quot;, data:&#123;&quot;name&quot;:&quot;张三&quot;,&quot;pwd&quot;:&quot;123&quot;&#125;, dataType:&quot;html&quot;, error:function()&#123; &#125;, success:function()&#123; &#125;, type:POST,&#125;); 第二层(简化$.ajax) $.get(url,data,success,dataType)) $.post(url,data,success,dataType) 第三层(简化$.get()) $.getJSON(url,data,success). 相当于设置$.get中dataType=”json” $.getScript(url,data,success)相当于设置$.get中dataType=”Script”","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"},{"name":"Ajax","slug":"Ajax","permalink":"https://Zhangbingwu.github.io/tags/Ajax/"}]},{"title":"Servlet路径问题","slug":"Servlet路径问题","date":"2019-07-24T16:00:00.000Z","updated":"2019-07-25T16:06:20.124Z","comments":true,"path":"2019/07/25/Servlet路径问题/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/25/Servlet路径问题/","excerpt":"","text":"Servlet重定向路径相对路径 从当前请求的路径查找资源的路径 问题：如果Servlet的别名中包含目录，会造成重定向失败。 绝对路径 第一个/表示服务器根目录，weboot /虚拟项目名/资源路径 Servlet请求转发相对路径 从当前请求的路径查找资源的路径 问题：如果Servlet的别名中包含目录，会造成请求转发失败。 绝对路径 第一个/表示项目根目录 /资源路径","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"Servlet学习02","slug":"Servlet学习02","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-27T12:14:16.973Z","comments":true,"path":"2019/07/24/Servlet学习02/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/Servlet学习02/","excerpt":"","text":"JSP学习JSP基本概念和运行原理 JSP基本概念JSP(java server pages),中文全称：java服务器页面,其根本是一个简化的Servlet设计，由sun公司倡导，许多公司参与一起建立的一种动态网页技术标准。（动态在于数据的动态） 特点 本质还是Servlet 跨平台，一次编写处处运行。（java） 组件跨平台 健壮性和安全性 运行原理见JSP运行原理。 JSP的page指令学习书写&lt;@ page 属性名=”” 属性名=”” 属性名=””…..&gt;属性之间空格隔开。 常见属性 1.import声明转译后的java文件要导入的包。 2.language声明JSP要转译成的语言。 3.pageEncodingJSP文件保存格式。 4.contentTypejsp数据响应给浏览器，浏览器的解析和编码格式。 5.errorPage设置jsp运行错误跳转页面 6.entends设置java文件要继承的父类（包名+类名） 7.session设置转译的servlet是否开启session支持，默认开启。 代码块 1.JSP的局部代码块：&lt;% %&gt;在_JspService()方法中。 2.JSP的全局代码块：&lt;%! %&gt;在方法外，全局的。 3.JSP的脚本段代码块：&lt;%= %&gt;相当于：out.write(); =之后写的就在括号内部。 缺点逻辑判断困难，阅读困难，尽量将业务处理，和页面展示分开。 静态引入＆动态引入 静态引入 &lt;%@ include file=&quot;相对路径&quot;&gt; 不会生成JspServlet文件 将两个jsp合并到后生成JspServlet 因此不能使用同名变量 动态引入 &lt;jsp:include page=&quot;相对路径&quot;&gt;&lt;/jsp:include&gt; 会生成JspServlet文件 能使用同名变量 优点降低代码冗余，便于维护升级。 请求转发forward标签 作用类似Servlet的请求转发，req.getRequestDispatcher(“”); 特点 一次请求 地址栏信息不改变 使用&lt;jsp:forward page=&quot;forward.jsp&quot;&gt;&lt;/jsp:forward&gt; 注意内部不允许任何字符，除了它的子标签&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;,子标签用于数据的流转，实现是 forward?name=value 请求参数拼接。 九大内置对象：service方法中自动声明的。 Request Response config：ServletConfig，获取每个Servlet单独的配置信息。 session：用户不同请求间数据共享。一次会话。 application：ServletContext，一个Servlet只能有一个，不同用户共享。 pageContext：封存了其他八个对象 page：类似于java中的this 代表这个Servlet out：响应对象，JSP内部使用，带有缓冲区的响应对象，效率高于Response。（不能做一些类似设置响应头的工作） exception：异常对象，存储了当前运行异常信息。（注意：需要在page指令中isErrorPage=”true”开启） jsp绝对路径 /虚拟项目名/资源路径第一个/代表web项目，Localhost：8080/","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://Zhangbingwu.github.io/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"JSP运行原理","slug":"JSP运行原理","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-24T05:55:20.703Z","comments":true,"path":"2019/07/24/JSP运行原理/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/JSP运行原理/","excerpt":"","text":"运行原理是为了书写HTML方便而产生的，html文件通过处理，逐行读取并加上resp.getWriter().writer(),就成为了服务器认识的Servlet。 通过tomcat下web.xml中公共配置可以发现： 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt; 找到org.apache.jasper.servlet.JspServlet这是转译后的jspServlet 123public final class jspPro_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; 这是里面的_jspService方法 12public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; 找到org.apache.jasper.runtime.HttpJspBase反编译后： 1public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123; 发现其父类继承了HttpServlet，再看他的service方法 123456@Overridepublic final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; _jspService(request, response);&#125; 其又调用了HttpJspBase中_jspService方法。 1234567891011out.write(&quot;\\r\\n&quot;);out.write(&quot;\\r\\n&quot;);out.write(&quot;&lt;!--\\r\\n&quot;);out.write(&quot; JSP的三种注释：\\r\\n&quot;);out.write(&quot; 1.前端语言注释：\\r\\n&quot;);out.write(&quot; 会被转译，会被发送，不会被浏览器执行\\r\\n&quot;);out.write(&quot; 2.java语言注释：\\r\\n&quot;);out.write(&quot; 会被转译，不会被Servlet执行\\r\\n&quot;);out.write(&quot; 3.JSP注释：\\r\\n&quot;);out.write(&quot; 不会被转译\\r\\n&quot;);out.write(&quot;--&gt;&quot;); 里面的方法类似resp.getWriter().writer(),只是进行了封装。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Zhangbingwu.github.io/categories/随笔/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://Zhangbingwu.github.io/tags/JSP/"}]},{"title":"ServletContext在案例中使用空指针问题","slug":"ServletContext在案例中使用空指针问题","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-23T16:51:23.089Z","comments":true,"path":"2019/07/24/ServletContext在案例中使用空指针问题/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/ServletContext在案例中使用空指针问题/","excerpt":"","text":"ServletContext在案例中使用问题ServletContext在案例中使用简单的网站案例，添加网站访问次数计数器，ServlertContext实现不同用户共享访问次数信息，并更改，从而达到网站访问计数器功能，功能实现没有问题，但是由于ServletContext生命周期从服务器开启到关闭，访问次数信息需要保存到外部文档中，因此在服务器启动，和服务器关闭时加入流操作，获取和存储访问次数信息，从而达到服务器重启后访问次数存在。 问题 服务器每次关闭都会报空指针错误，没有具体指明错误代码，因此我觉得时destroy()方法中出现的错误。 出现空指针异常，审查过后只有一处可能出现。String nums = (Sting)this.getServletContext().getAttribute(&quot;nums&quot;)是否因为获取的nums次数为null，由于强转引起的空指针问题？并且通过简单的System.out.println(nums);确定了是此处问题。 既然是强转出问题，不确定获得的nums是否为null，我用Object nums = this.getServletContext().getAttribute(&quot;nums&quot;)并输出nums值发现不为null，因此排除了null可能，但是也发现这种方法没有报错。 最终怀疑是否(String)强转的问题，我改用String nums = String.valueOf(this.getServletContext().getAttribute(&quot;nums&quot;));的方式，问题得以解决。","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"intellij idea在运行web项目时部署的位置(tomcat)","slug":"intellij idea在运行web项目时部署的位置(tomcat)","date":"2019-07-22T16:00:00.000Z","updated":"2019-07-23T05:05:22.643Z","comments":true,"path":"2019/07/23/intellij idea在运行web项目时部署的位置(tomcat)/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/23/intellij idea在运行web项目时部署的位置(tomcat)/","excerpt":"","text":"别的 今天好奇IDEA中web项目是怎么通过tomcat运行的？原因在于MyEclipse中web项目在tomcat中webapps目录下以其虚拟项目名创建的目录中有着运行所需要的webroot目录，那么IDEA中web项目在tomcat的哪里呢？通过百度了解到了相关知识。 具体参见 war exploded和war包 war exploded模式（开发模式）是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。On’Updata’action 和 On frame deactivation都改成Update resources。 war包则是项目发布常用的模式。 intellij idea在运行web项目时部署的位置(tomcat) A-首先实际运行的位置在项目所在目录\\out\\artifacts\\项目名_war_exploded下 B-tomcat中运行的是根据${user.home}/.IntelliJIdea/system/tomcat/项目名/conf/Catalina/localhost下的xml文件找到实际运行的位置即A中。可以在IDEAtomcat配置里Deployment更改Application context项目虚拟名，从而修改启动的URL，这在B目录下的xml文件中可以体现","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://Zhangbingwu.github.io/tags/IDEA/"}]},{"title":"","slug":"web项目中数据库加载驱动ClassNotFound","date":"2019-07-21T16:19:09.741Z","updated":"2019-07-24T07:57:23.297Z","comments":true,"path":"2019/07/22/web项目中数据库加载驱动ClassNotFound/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/22/web项目中数据库加载驱动ClassNotFound/","excerpt":"","text":"title:IDEAweb项目中数据库加载驱动ClassNotFoundweb项目中数据库加载驱动ClassNotFound通过报错信息确定dao层数据库连接查询的问题,控制台报错com.mysql.cj.jdbc.Driver ClassNotFoundException,发现是数据库连接jar包所在的lib文件夹位置的问题。 解决导入数据库连接jar包到web-&gt;WEB-INF-&gt;lib文件夹下。 补充（7-23）此种模式称为war exploded模式（开发模式）直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。","categories":[],"tags":[]},{"title":"","slug":"MVC思想","date":"2019-07-21T16:18:55.039Z","updated":"2019-07-24T07:56:44.577Z","comments":true,"path":"2019/07/22/MVC思想/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/22/MVC思想/","excerpt":"","text":"title:MVC思想MVC思想 参考至 MVC（Model View Controler）模型，视图，控制器 视图作用于用户，一种用户用来操作的界面，浏览器，程序页面等以便于用户输入信息。 控制器控制器接受用户的输入并调用模型和视图去完成用户的需求 模型业务逻辑模型，具体的分析数据，实现业务。 流程根据用户输入信息或发送的请求，调用对应的业务层接口，业务层通过调用dao层操作数据库获取信息，信息反馈给业务层，业务层根据信息不同响应用户不同的展示。 其他 Servlet接受请求，用户数据 service（业务层）定义接口，检查是否有用户信息，并返回用户信息的实体类 pojo存储用户信息的实体类 dao层，（数据库连接层）数据库层的接口，将用户信息和数据库比较，实现具体的业务JDBC步骤： 声明JDBC对象 加载驱动 获取连接 创建Sql命令 创建Sql命令对象 给占位符赋值 执行 遍历执行结果 关闭资源 返回 数据库存储用户信息","categories":[],"tags":[]},{"title":"Servlet学习01","slug":"Servlet学习01","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-23T16:32:32.595Z","comments":true,"path":"2019/07/20/Servlet学习01/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Servlet学习01/","excerpt":"","text":"服务器什么是服务器？ 可以实时地调用不同的代码的一个容器。 Servlet技术Servlet概念 Server AppletServlet（Server Applet）：全称Java Servlet。是基于Java技术的web组件，由容器管理并产生动态内容。Servlet引擎作为WEB服务器的扩展提供支持Servlet功能。Servlet与客户端通过Servlet容器实现的请求/响应模式进行交互。动态web开发技术。 为什么有Servlet技术？ 服务器接收到浏览器请求后,自动调用对应逻辑代码进行请求处理,但是逻辑代码是有程序员编写并放到服务器中,那么服务器怎么知道该怎么调用？调用哪个类？哪个方法进行请求处理？ 程序员在编写代码的时候能够按照服务器能够识别的规则进行编写,浏览器按照指定的规则进行发送请求,那么服务器就可以调用并执行相应逻辑的代码进行请求处理。 狭义的Servlet是指Java实现的一个接口 通过实现这个接口从而规范代码书写。 广义的Servlet是指任何实现了这个接口的类 一般人们理解为广义的。 使用IDEA配置和使用Tomcat IDEA配置和使用Tomcat 步骤 1.类需要继承HttpServlet其父类实现了Servlet接口,保证了规范。 2.重写方法 3.方法中书写逻辑代码 4.在webRoot下的WEB-INF文件夹下的web.xnml文件中配置servlet 组成如http://localhost:8080/project/test服务器地址:端口/虚拟项目名/Servlet别名 Servlet生命周期具体过程1.启动web服务器解析web.xml 2.第一次接收到客户端请求,服务器判断Servlet实例是否存在，加载Servlet并创建实例 3.init()并调用请求相应方法 4.等待其他请求 5.服务器关闭,Servlet销毁,destroy()1.从第一次接收到请求,到服务器关闭2.如果web.xml配置了load-on-startup,生命周期从服务器启动,到服务器关闭。service()和doGet()和doPost()service()可以处理get/post方式的请求,如果servlet中有service方法,会优先调用service方法对请求进行处理。doGet()处理get方式的请求doPost()处理post方式的请求注意*如果在重写的service方法中调用了父类的service方法(super.service(req, resp);),则service方法处理完后,会再次根据请求方式相应的doGet和doPost方法。所以,一般情况下,我们是不在重写的service中调用父类的service方法的,避免出现405错误(请求方式不匹配)*Servlet常见错误404错误：资源未找到 请求地址中虚拟项目名以及Servlet别名检查是否与web.xml匹配。 500错误：内部服务器错误 ClassNotFoundException:com.xxx.xxx检查web.xml中Servlet类的全限定路径是否错误servlet-class service方法体代码逻辑错误。 405错误：请求方式不支持 检查get和post请求方式是否有匹配的doGet和doPost 一般使用service方法且不要调用父类 Request对象什么是Request对象？服务器接受到请求后,需要存储请求,并保证请求数据的完整性,因此创建一个对象来保存,在service方法执行时作为实参传递到service方法中。获取请求数据 获取请求头数据 req.getMethod() //获取请求方式 req.getRequestURL() //获取请求URL req.getRequestURI() //获取请求URI URI就是具体的资源路径 req.getScheme() //获取请求协议信息 获取请求行数据 req.getHeader(“键名”) //获取指定的附加信息 req.getHeaderNames() //获取所有的附加信息的键名 返回枚举类型12345678Enumeration&lt;String&gt; names = req.getHeaderNames(); //返回枚举类型 //遍历枚举 while(names.hasMoreElements())&#123; String name = names.nextElement(); //根据键名查询值 String value = req.getHeader(name); System.out.println(name+value); &#125; 获取请求主体 req.getParameter(“键名”) //获取指定的用户数据 req.getParameterValues(“键名”) //获取同名不同值的用户数据 返回数组 req.getParameterNames() //获取所有的用户数据的键名 返回枚举类型 注意如果键名匹配出现问题,返回null,因此需要注意空指针问题。 Request对象作用域 解决了不同的Servlet之间数据共享问题，也就是数据能从一个Servlet流转到另一个Servlet中。 使用：req.setAttribute(object name,object value);req.getAttribute(object name); //根据类型不同强转 作用域基于请求转发，一次请求内的所有Servlet有效。 Request对象特点 服务器创建 每次请求都会创建（http的无状态） 生命周期–一次请求（基于请求转发） Response对象作用对请求做出响应设置响应数据 设置响应头 resp.setHeader(String name,String name); //会覆盖掉原来的 resp.addHeader(String name,String name); //会继续添加 设置响应编码格式resp.setHeader(“content-type”,”text/html;charset=utf-8”);resp.setContentType(“text/html;charset=utf-8”); 设置响应状态resp.sendError(int num,String msg); 设置响应实体esp.getWriter().write(String content); 请求中文乱码解决1.使用String进行数据重新编码uname = new String(uname.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);2.使用公共配置 get方式 req.setCharacterEncoding(“utf-8”); tomcat的目录下的配置文件conf目录中修改server.xml,在connector标签下添加属性，useBodayEncodingForURI=”true”; post方式req.setCharacterEncoding(“utf-8”); 注意 useBodyEncodingForURI=”true”是说，请求参数的编码方式要采用请求体的编码方式。 而filter的request.setCharacterEncoding(‘UTF-8’)或者请求header中的content-type中的编码都是针对请求体的。 URIEncoding是针对请求参数的编码设置的。 请求转发 作用实现多个Servlet联动操作处理请求，这样避免了代码冗余，让Servlet职责更加明确。 使用req.getRequestDispatcher(“要转发的地址”).forward(req,resp);地址：相对路径，直接书写Servlet别名。 特点一次请求，浏览器地址信息不会变化。 注意请求转发后直接return，交由其他Servlet来响应。 响应重定向 解决了表单重复提交的问题，以及此Servlet无法处理请求的的问题 使用： resp.sendRedirect(String uri);如果是网络资源String url 实例： resp.sendRedirect(&quot;/login/m&quot;); 特点 两次请求，两个request 浏览器地址信息会发生变化，因为请求不同。 使用时机 如果请求中由表单数据（由form表单收集的用户信息）且比较重要不能重复提交，建议使用重定向。 如果这个Servlet无法处理此请求，建议使用重定向定位到可以处理的资源。（如：淘宝购买商品，购买后淘宝定向到支付宝） CookieCookie的作用和特点 作用解决发送的不同请求间的数据共享问题。 特点 临时存储如果没有设置Cookie有效期，那么这个Cookie对象为临时存储，存储在浏览器的运存中，重新打开浏览器Cookie对象失效。 定时存储设置Cookie有效期后，这个Cookie对象为定时存储，存储在客户端硬盘中，在有效期内符和路径要求的请求都会附带该信息。 浏览器端的数据存储技术。 存储数据的声明在服务器端。 注意： 一个Cookie对象只能存储一条数据,以键值对的形式存储。 Cookie的使用 Cookie的创建，设置和响应 创建Cookie对象Cookie ck = new Cookie(&quot;uname&quot;,&quot;zhangsan&quot;); 设置Cookie有效期–以s为单位的intck.setMaxAge(2*24*3600); 设置Cookie有效路径–urick.setPath(&quot;/cookie/abc&quot;);只有访问这个路径，请求才会携带cookie信息 响应Cookie信息到浏览器resp.addCookie(ck); Cookie的获取 Cookie[] cks = req.getCookies();返回一个由Cookie对象的数组。 注意：如果Cookie中没有数据，获取的cks为null，如果遍历获取内容出现空指针问题。1234567if(cks != null)&#123; for(Cookie ck:cks)&#123; String name = ck.getName(); String value = ck.getValue(); System.out.println(name+&quot;:&quot;+value); &#125;&#125; 为什么要进行Cookie校验例子：用户登录成功，创建Cookie对象，（！注意，Cookie对象的创建，因为Cookie直接在响应头和请求头中，不要涉及密码等隐私，安全问题。）如果不进行校验，用户注销（数据库中删除了用户数据），用户再次登录就会发生问题。 Session技术Session作用及其原理 作用解决了用户发起的不同请求，服务器在对不同请求处理时用户请求信息的共享。 原理用户登录成功后，服务器为其创建一个session对象，用于存储用户的信息，方便以后使用。而怎么让用户第二次请求时拿到正确的session对象？服务器创建session对象后，将对应的JSESSIONID（类似于号码牌，对应其session对象）利用Cookie技术存储到浏览器中，那么请求时通过这个ID就能找到对应的session对象，从而使不同请求可以调用session对象来共享数据。 Session的使用创建Session/获取Session对象`HttpSession hs = req.getSession();` 注意：创建还是获取，依据于请求中是否有session的标识符JSESSIONID，有就返回对应的session对象，没有就创建新的session对象，并将JSESSIONID作为Cookie数据存储在浏览器运存中。（所以只要重启浏览器就会丢失Cookie数据即JSESSIONID，临时存储，session对象存储在服务器中） 设置session存储时间（默认存储时间：30min）hs.setMaxInactiveInterval(int seconds);注意：在指定时间内session对象没有被使用则销毁，指定时间内使用了就会重新计时。 设置session立即销毁hs.invalidate(); session存储/获取数据 存储和获取 存储：hs.setAttribute(String name,Object value);可以存放对象。 获取：String name = (String) hs.getAttribute(&quot;name&quot;);返回Object类型需要强转。 注意：存储的动作和去除的动作发生在不同的请求中，但是存储要先于取出执行。 使用时机：一般用户在登录web项目时会将用户的个人信息存储Session中，供其他请求使用。 Session的特点 1.依赖于Cookie技术 2.生命周期为：一次会话JSESSIONID存储在Cookie的临时存储空间中，即浏览器运存中，浏览器关闭就会失效。 3.默认存储时间30min Session的作用域 一次会话 当浏览器JSESSIONID和服务器的SESSION对象都未失效时，作用于整个web项目中。 Session的失效处理 判断浏览器JSESSIONID和服务器的JSESSIONID是否一致。 判断根据浏览器JSESSIONID拿到的session对象数据是否为null。 ServletContext对象的学习基本概念 作用解决了不同用户之间数据的共享问题。 原理类似session对象的原理，服务器创建一个对象，不同的是所有的用户都可以获取并使用。 特点 用户共享 服务器创建 作用域整个项目内。 生命周期服务器启动到服务器关闭。 ServletContext的使用 1.获取ServletContext对象，三种获取方式 ServletContext sc = this.getServletContext(); ServletContext sc2 = this.getServletConfig().getServletContext(); ServletContext sc3 = req.getSession().getServletContext();注意：这三种方式创建的ServletContext对象都是同一个。 2.ServletContext存储数据/获取数据 存储sc.setAttribute(String name,Object value); 获取,返回Object类型Object o = sc.getAttribute(String name); 3.全局参数的设置及获取 web.xml中全局数据配置 1234&lt;context-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;zhangsan&lt;/param-value&gt; &lt;/context-param&gt; 获取web.xml全局配置数据sc.getInitParameter(user);返回对应的值String类型。sc.getInitParameterNames();返回获取web.xml全局配置数据键名的枚举。作用：将静态数据和代码解耦。 3.获取项目webroot下资源的绝对路径String path = sc.getRealPath(&quot;/doc/1.txt&quot;);path为项目根目录补全后的绝对路径。 4.获取项目webroot下资源的流对象InputStream is = sc.getResourceAsStream(&quot;/doc/1.txt&quot;);注意：此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取。 ServletConfig对象学习作用 获取web.xml给每个Servlet单独的配置信息 使用 给每个Servlet单独的配置 1234&lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; 获取ServletConfig对象ServletConfig sc = this.getServletConfig(); 获取servlet配置信息String code = sc.getInitParameter(&quot;config&quot;); server.xml大体组件内容1234567891011&lt;Server&gt; &lt;Service&gt; //可以配置多个Service &lt;Connector /&gt; //端口 可以有多个端口 &lt;Connector /&gt; &lt;Engine&gt; //引擎 一个Service只能有一个 &lt;/Host&gt; &lt;context /&gt; //热部署配置 &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 热部署&lt;Context path=&quot;/项目别名&quot; reloadable=&quot;true&quot; docBase=&quot;项目所在绝对路径&quot; /&gt;注意：如果需要映射的docBase下的文件被删除，服务器启动会报错，而冷部署如果webapps下没有，服务器启动也不会报错。 总结 Servlet使用流程 设置请求编码格式 通用方式（String编码） 公共配置：get请求数据在请求参数中，和post请求数据在请求体中。 设置响应编码格式 resp.setContentType(&quot;text/html;charset=utf-8&quot;); 获取请求数据 获取Cookie数据 Cookie[] cks = req.getCookies();返回有Cookie对象的数组，遍历注意空指针问题。 Session优化 ServletContext优化 获取用户信息 String uname = req.getParameter(&quot;uname&quot;); 处理请求数据 获取业务层对象，调用业务层方法。 响应处理结果 直接响应 resp.getWriter().writer(&quot;&quot;); 请求转发 req.getRequestDispatcher(&quot;servlet别名&quot;).forward(req,resp); 响应重定向 resp.sendRedirect(&quot;servlet的uri&quot;);","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"Http协议学习","slug":"Http协议学习","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-30T07:30:22.090Z","comments":true,"path":"2019/07/20/Http协议学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Http协议学习/","excerpt":"","text":"了解Http什么是Http？ 全称Hyper Text Transfer Protocol（超文本传输协议） 作用1.用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。2.是对服务器和客户端交流的格式规范。3.没有http协议也可以达到交流的目的,但是影响推广。 Http工作原理 HTTP是一个基于TCP/IP通信协议族来传递数据（HTML 文件, 图片文件, 查询结果等）。 https://www.jianshu.com/p/9f3e879a4c9c HTTP默认端口号为80 HTTP特点 简单快速发送请求时，只需要传送请求方法和路径。请求方法常用的有：GET,POST,HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单,使得HTTP服务器的程序规模很小,因而通信速度块。 媒体独立服务器可以接受客户端发送的任何类型的数据,并用content-type对正文内容类型加以标记。 无连接无连接的含义是限制每次连接只处理一个请求。客户端请求,服务器处理并相应,收到客户端应答后连接断开。这种方式可以节省传输时间。注意:HTTP 1.1 后支持持续连接。 无状态服务器每次接受到请求后,处理响应,但是不会记忆请求信息,如果需要第二次请求,即使内容相同也要重新发送请求信息,这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。联想填寄快递单。 HTTP交互流程 客户端与服务器建立连接。 客户端向服务端发送请求。 服务端接受处理请求,做出响应。 关闭客户端与服务器的连接。(HTTP1.1之后不会立即关闭) HTTP消息结构请求消息请求头:请求方式 URL 协议版本。 请求行:消息报头,一般用来说明客户端需要使用的一些附加信息。 空行:必须要有。 请求主体响应消息状态行:协议版本,状态码,状态描述。 响应头:消息报头,客户端使用的附加信息,时间,conten-type,content-length。 空行:必须要有 响应正文不同的请求方式,消息结构会有一些差异。 GET方式没有请求主体,直接以？隔开拼接在请求地址后。 HTTP请求方式GET请求方式 特点 get方式只能传输少量数据,不是因为http协议,而是因为地址栏长度有限制。 没有请求主体,直接以？隔开拼接在请求地址后。 不安全,因为请求信息暴露。 效率高。 POST请求方式 特点 POST方式可以传输大量数据。 请求信息可以都放在请求主体中,也可以拼接在请求地址后,可以合在一起用。 安全。 效率相比GET低。 不同请求方式使用 第一衡量指标：安全 然后考虑数据量。 状态码状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用HTTP状态码共分为5种类型： 1** 信息 2** 成功 3** 重定向 4** 客户端错误 5** 服务器错误 常见状态码 200 OK //客户端请求成功 400 BadRequest //客户端请求有语法错误 401 Unauthorized //请求未经授权 403 Forbidden //服务器拒绝提供服务 404 Not Found //请求资源不存在 500 Internal Server Error //服务器发生了不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端请求,一段时间后会恢复","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://Zhangbingwu.github.io/tags/Http/"}]},{"title":"jQuery的封装原理","slug":"jQuery的封装原理","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-18T17:11:54.558Z","comments":true,"path":"2019/07/19/jQuery的封装原理/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的封装原理/","excerpt":"","text":"jQuery的封装原理1.为什么要用”闭包”？ 1.内部声明和外部声明重名问题，因为变量被覆盖，导致函数失效。 2.可以使用对象对函数进行封装，但是对象如果被覆盖，则被封装的所有函数失效。 123456var obj = &#123;&#125;;obj.test = function()&#123; alert(&quot;外部test&quot;);&#125;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 3.使用工厂模式，将代码进行封装，但是还是可能被覆盖。 1234567891011121314//工厂模式function factory()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125;&lt;script type=&quot;text/javascript&quot;&gt; var obj = factory();&lt;/script&gt;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 4.问题根源在于名字，那么去掉名字就好了，但是没有名字的函数应该怎么调用？ 1234567function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125; 5.使用匿名自调用，但是只能用一次,并且无法获取数据。 123456789//匿名自调用(function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; alert(&quot;匿名自调用&quot;); return obj;&#125;)() 6.使用闭包。","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"jQuery的学习","slug":"jQuery的学习","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-30T04:21:05.942Z","comments":true,"path":"2019/07/19/jQuery的学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的学习/","excerpt":"","text":"jQuery的选择器学习 1.基本选择器- 1.id $(&quot;#id&quot;); - 2.标签名 $(&quot;标签名&quot;); - 3.类 $(&quot;.类名&quot;); 如:$(&quot;.common&quot;); - 4.全部 $(&quot;*&quot;); - 5.组合 如：$(&quot;id,标签名,····&quot;); -注意：jQuery选择器返回的是装有元素对象的数组。id选择器是装有一个对象的数组。2.层级选择器1.ancestor descendant 祖先 后代 $(&quot;祖先 后代 &quot;) 2.parent &gt; child :在给定的父元素下匹配所有的子元素 $(&quot;form &gt; input&quot;) 注意：只有子元素，孙子元素不能。 3.prev + next :匹配所有紧接在 prev 元素后的 next 元素 $(&quot;label + input&quot;)注意：这里是紧接的，也就是下一个！ 4.prev ~ siblings :匹配 prev 元素之后的所有 siblings 元素 $(&quot;form ~ input&quot;) 注意：找到所有与表单同辈的 input 元素3.简单选择器对获得的对象数组进一步过滤，从而得到需要的对象。 如：&apos;$(&quot;li:first&quot;);&apos;所有li标签对象数组中的第一个。 &apos;$(&quot;li:not([class])&quot;);&apos;所有li标签对象数组中不包含class属性的 :even,:odd 索引的奇偶判断 :eq(index);索引为index的对象 :gt(index);索引为index以后的对象 :it(index);索引为index以前的对象 :header; h1,h2,h3之类的标题元素4.属性选择器$(&quot;input[id=&apos;1&apos;]&quot;); != 不为某些值;^= :以某些值开头;$= ：以某些值结尾;*= ：包含某些值 多个合一块用：$(&quot;input[id],name=&apos;zs&apos;&quot;);5.表单选择器:表单元素 选择该类表单元素的对象数组。 如： $(&quot;:text:eq(0)&quot;) form表单中 type属性为text的第一个对象。6.内容选择器$(&quot;b:contains(&apos;你好&apos;)&quot;);b标签中的值是‘你好’的b标签元素对象数组。 $(&quot;div:has(p)&quot;);所有包含p标签的div标签元素对象数组。7.可见性选择器:visible 可见的标签 :hidden 不可见的标签jQuery操作元素属性:1.获取属性对象数组.attr(&quot;&quot;); 注意：对象数组.attr(&quot;value&quot;);只能获得默认的值，不能动态更新， 类似自定义属性的getAttribute();可以使用 对象数组.val();2.修改属性对象数组.attr(&quot;类型&quot;,&quot;新值&quot;);jQuery操作元素内容1.获取元素内容对象数组.html(); 对象数组.text(); 两者的区别同innerHTML和innerText一样。2.修改元素内容对象数组.html(&quot;新内容&quot;); 对象数组.text(&quot;新内容&quot;); 两个都会覆盖原有内容。jQuery操作元素样式:1.对象数组.css();- 对象数组.css(&quot;width&quot;); 获取width值 - 对象数组.css(&quot;属性名&quot;,&quot;属性值&quot;); - json方式 对象数组.css({&quot;&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;,···}); 不同样式之间逗号隔开 如：`div02.css({&quot;height&quot;:&quot;300px&quot;,&quot;width&quot;:&quot;300px&quot;,&quot;border&quot;:&quot;solid 1px black&quot;});`2.对象数组.addClass(“类名”);- 对象数组.addClass(&quot;类名1 类名2&quot;); 不同类之间 空格隔开#jQuery操作文档结构: 1.内部插入：1.append() 追加 2.appendTo() 将元素对象追加到指定的元素对象中，并删除该元素对象。 3.prepend() 追加到之前 4.prependTo()2.外部插入：1.after() 在元素对象的外部插入 2.insertAfter() 作用类似于 appendTo 不过插入位置是元素对象外部 3.before() 4.insertBefore()3.包裹1.wrap() 参数可以是HTML，或者已经有的对象。 2.unwrap() 和wrap()配合使用。4.替换1.replaceWith() 2.replaceAll() 两个实际一样，主从关系不同。5.清空- empty() innerHTML=&quot;&quot;;还有一个空占位符,而empty()将内部清空,直接为null。6.移除1.remove(); 如： $(&quot;p&quot;).remove(); 去除p标签 $(&quot;p&quot;).remove(&quot;.hello&quot;); 把带hello类的p标签去除 2.detach(); 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。7.clone();jQuery操作事件:1.bind(“事件名”,fn)注意： 与js不同的是：js通过覆盖onclick属性动态操作事件,因为覆盖了之前的,所以只能动态地为其他元素的一个监听事件添加一个函数; 而jQuery是追加地,可以动态地为其他元素的一个监听事件添加多个个函数;2.unBind(“事件名”)1.只能解绑用bind绑定的事件 2.解绑了这个事件，也就解绑了这个事件监听的所有函数。 注意:jQuery3.0中弃用了bind和unBind，用on()和off()替代。3.one()1.添加一次性事件，执行事件被触发后即失效。 2.可以给事件添加多个一次性函数。 3.可以用unBind()解绑。4.页面载入事件：$(document).ready(fn); 简写:$(fn); 与window.onload=fn不同的是：jQuery页面载入事件不会覆盖，而js页面载入事件后面的会覆盖之前的。jQuery动画效果就是HTML元素的隐藏和显示。show()- show(1000); 1s后显示 - show(1000,fn); 1s后显示并且执行某个函数hide()同show()toggle()- toggle() 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。slideDown(),slideUp(),slideToggle()- slideDown() slideDown(1000) 1s内向下滑动显示出来 - slideToggle()fadeIn(),fadeOut(),fadeToggle()淡入淡出效果。animate()- 自定义的动画效果。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"超链接标签调用js函数","slug":"超链接标签调用js函数","date":"2019-07-18T14:25:45.056Z","updated":"2019-07-18T14:36:05.876Z","comments":true,"path":"2019/07/18/超链接标签调用js函数/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/超链接标签调用js函数/","excerpt":"","text":"超链接标签调用js函数 1.&lt;a href =&quot;#&quot; onclick =&quot;js_method()&quot;&gt;这个方法中的#号代表top，所以点击之后会跳转到页面最顶端2.&lt;a href = &quot;javascript:void(0);&quot; onclick =&quot;js_method()&quot;&gt;文本&lt;/a&gt;这是最常用的方法。前面的void（0）返回undefined，地址不会发生跳转，后面的onClick负责执行js函数。这样写还有一个好处是不会吧js方法暴露在浏览器的状态栏","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"},{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/tags/知识/"}]},{"title":"js操作表格及表格小案例","slug":"js操作表格及表格小案例","date":"2019-07-18T12:11:20.000Z","updated":"2019-07-18T14:35:18.020Z","comments":true,"path":"2019/07/18/js操作表格及表格小案例/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/js操作表格及表格小案例/","excerpt":"","text":"1.回顾表格1.HTML表格 a &lt;table border=&quot;1px&quot;&gt; 整个表格,表格加边框，这里是每个单元格td加边框。 b &lt;tr&gt; 表格中的行 c &lt;td&gt; 单元格 d table&gt;tr*3&gt;td*3 : 3行3列表格2.js操作表格1.大致套路1.获取表格对象 2.由于需要动态的操作这里使用间接方式获取tr对象。 例如：在一个单元格td中有一个checkbox按钮，通过var chk = getElementById()获取该按钮对象， 那么chk.parentNode就是单元格td对象，chk.parentNode.parentNode就是行tr对象。 3.通过表格对象.deleteRow(行号);表格对象.insertRow(行号);来进行增加，删除表格的行。 注意： 1.这里的行号从0开始。 2.不同于其他 父节点.removechild(子节点对象) 父节点.appendChild(子节点对象); 4.其他还是通过js操作表格的属性进行相应操作。 如：ta.rows[i].style.backgroundColor=&quot;red&quot;;动态改变表格颜色。2.小知识点1.行对象.rowIndex 获得该行的行号; 2.可以通过getElementByName()获取所有的行对象，对行对象数组遍历，并进行操作。 3.添加行功能时，表格对象.insertRow(行号) 返回新添加的行对象;只是添加了一个空行， 需要,行对象.insertCell();进行单元格添加。 4.表格对象.rows.length 表格总行数3.问题1.删除功能 问题：1.同时选中两个删除不能全部删除。2.全选删除时首行被删除，解决：循环初始值i设为1，忽略首行。 原因：每删除一行后，行对象数组长度同时-1。 例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3）那么i此时为2，而行号2此时没有被选择因此不能通过判断。 解决：每次删除后 判断框内 i-- 担心问题：同时删除行号1和3会不会失败？ 不会，因为1删除后，2不会进入判断，不会进行i--。 2.修改数量功能 问题：多次点击后，出现bug。 原因：多次点击，由于字符串拼接，新的innerHTML被拼接进input标签text的value属性中。 解决：进行判断，利用isNaN()判断是否为数字，是数字再进行拼接。3.具体源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;html&gt; &lt;head&gt; &lt;title&gt;js操作表格&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;!-- 总结： 1.获取tr对象 通过删除按钮地父节点.父节点; 2.表格删除行操作 ：表格对象.deleteRow(行号); 3.行对象.rowIndex 获得该行的行号; --&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; text-align: center; &#125; /*表格居中*/ #ta01&#123; margin: auto; margin-top: 80px; &#125; #ta01 tr&#123; height: 60px; text-align: center; &#125; #tr01&#123; font-size: 24px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //删除功能 function deleRow(btn)&#123; //获取table对象 var ta = document.getElementById(&quot;ta01&quot;); //获取tr对象 var tr = btn.parentNode.parentNode; //获取tr对象 通过删除按钮地父节点.父节点 //删除 ta.deleteRow(tr.rowIndex); //表格删除行操作 表格对象.deleteRow(行号); &#125; //修改功能 function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125; &#125; //保存修稿功能 function updataBlur(inp)&#123; //获取td对象 var cell = inp.parentNode; cell.innerHTML = inp.value; &#125; //------------------------------------------------------- //使用checkbox删除，功能可多选删除 function deleMore()&#123; //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.获取tr对象，通过 表格对象.deletRow() var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; //从1开始，避免首列被删除 //删除被选择的对应行号 if(chks[i].checked)&#123; //注意：这里每删除一行后，chks长度同时-1，例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3） //那么i此时为2，而行号2此时没有被选择因此不能通过判断。 //解决：每次删除后 i-- //担心问题：同时删除行号1和3会不会失败？ 不会因为1删除后，2不会进入判断，不会进行i--。 ta.deleteRow(i); i--; &#125; &#125; &#125; //完成添加功能 function addRow()&#123; //表格对象.insertRow() 行号 //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.添加行 返回添加的行对象 var row = ta.insertRow(1); //3.添加单元格 返回添加的单元格对象 //4.添加单元格内容 注意单引号 var cell00 = row.insertCell(); cell00.innerHTML=&quot;&lt;input type=&apos;checkbox&apos; name=&apos;chk&apos; id=&apos;chk&apos;/&gt;&quot;; var cell01 = row.insertCell(); cell01.innerHTML=document.getElementById(&quot;yxname&quot;).value; var cell02 = row.insertCell(); cell02.innerHTML=document.getElementById(&quot;yxprice&quot;).value; var cell03 = row.insertCell(); cell03.innerHTML=document.getElementById(&quot;yxcount&quot;).value; var cell04 = row.insertCell(); cell04.innerHTML=&quot;&lt;input type=&apos;button&apos; value=&apos;修改数量&apos; onclick=&apos;updataRow()&apos;/&gt;&lt;input type=&apos;button&apos; value=&apos;删除&apos; onclick=&apos;deleRow(this)&apos;/&gt;&quot;; &#125; //复制功能 再最后一行显示复制的 function copyRow()&#123; //添加新的行到最后一行 var ta = document.getElementById(&quot;ta01&quot;); var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; if(chks[i].checked)&#123; var copy = ta.insertRow(ta.rows.length); //ta.rows.length表格总行数 copy.innerHTML = ta.rows[i].innerHTML; //这里不需要i--，因为总长度只会增不会减少而发生错误。 &#125; &#125; &#125; //全选功能 function chooseAll()&#123; //所有的多选框同时选择，或同时取消，更改属性checked为true //获取所有的checkbox var chks = document.getElementsByName(&quot;chk&quot;); //获取全选按钮对象 var all = document.getElementById(&quot;chkk&quot;); if(all.checked)&#123; //遍历所有的checkbox for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=true; &#125; &#125;else&#123; for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=false; &#125; &#125; &#125; //隔行变色功能 function changeColor()&#123; var ta = document.getElementById(&quot;ta01&quot;); //获取所有行 var chks = document.getElementsByName(&quot;chk&quot;); //遍历 for(var i=1;i&lt;chks.length;i++)&#123; if(i%2==0)&#123; ta.rows[i].style.backgroundColor=&quot;cornflowerblue&quot;; &#125;else&#123; ta.rows[i].style.backgroundColor=&quot;green&quot;; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;游戏购买清单&lt;/h3&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleMore()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;addRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;复制&quot; onclick=&quot;copyRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;隔行变色&quot; onclick=&quot;changeColor()&quot;/&gt; &lt;hr /&gt; &lt;table id=&quot;ta01&quot; border=&quot;1px&quot;&gt; &lt;tr id=&quot;tr01&quot;&gt; &lt;td width=&quot;50px&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chkk&quot; value=&quot;0&quot; onclick=&quot;chooseAll()&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;名称&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;价格&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;数量&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;1&quot; /&gt;&lt;/td&gt; &lt;td&gt;绝地求生&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;td id=&quot;cell&quot;&gt;2&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;2&quot; /&gt;&lt;/td&gt; &lt;td&gt;守望先锋&lt;/td&gt; &lt;td&gt;299&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;3&quot; /&gt;&lt;/td&gt; &lt;td&gt;死神&lt;/td&gt; &lt;td&gt;88&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr /&gt; &lt;b&gt;请输入需要添加的游戏信息：&lt;/b&gt;&lt;br /&gt; 游戏名：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxname&quot; value=&quot;&quot; /&gt; 价格：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxprice&quot; value=&quot;&quot; /&gt; 数量：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxcount&quot; value=&quot;&quot; /&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"}]},{"title":"MarkDown使用学习","slug":"MarkDown使用学习","date":"2019-07-18T01:22:11.000Z","updated":"2019-07-18T14:34:15.117Z","comments":true,"path":"2019/07/18/MarkDown使用学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/MarkDown使用学习/","excerpt":"","text":"一级标题hello hexo 这是三级标题 列表1a 子列表1 斜体哦 粗体哦 又粗又斜了b 子列表2 这里是引用的 &lt; c 子列表3 这是超链接 列表2public static void main(Sring[] args) 123456789function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125; 这里是源码1234567891011121314151617181920212223242526272829 ---title: MarkDown使用学习---# 一级标题## hello hexo![吉冈里帆](http://b-ssl.duitang.com/uploads/item/201712/27/20171227143148_envyt.jpeg)### 这是三级标题- 列表1 a 子列表1 *斜体哦* **粗体哦** ***又粗又斜了*** b 子列表2 &gt; 这里是引用的 &lt; --- c 子列表3 [这是超链接](https://www.baidu.com/)- 列表2 `public static void main(Sring[] args)`function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://Zhangbingwu.github.io/tags/MarkDown/"}]}]}