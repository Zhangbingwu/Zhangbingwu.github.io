{"meta":{"title":"却又像风","subtitle":null,"description":null,"author":"却又像风","url":"https://Zhangbingwu.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-07-18T07:04:21.000Z","updated":"2019-07-18T07:05:53.842Z","comments":true,"path":"categories/index.html","permalink":"https://Zhangbingwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-18T07:03:31.000Z","updated":"2019-07-18T07:04:01.872Z","comments":true,"path":"tags/index.html","permalink":"https://Zhangbingwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP/IP学习","slug":"TCPIP学习","date":"2019-07-30T07:30:18.627Z","updated":"2019-07-30T07:30:18.627Z","comments":true,"path":"2019/07/30/TCPIP学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/30/TCPIP学习/","excerpt":"","text":"TCP/IP什么是TCP/IP? 是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及http、ftp、pop3协议等等。 作用定义计算机交流语言，使得计算机之间可以自由交流。 TCP/IP协议分层 TCP/IP三次握手和四次挥手 参考至 三次握手术语 SYNSYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。 ACKACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。 全双工（Full Duplex）全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。单工就是在只允许甲方向乙方传送信息，而乙方不能向甲方传送 。 步骤： 第一次：client向server发送SYN握手信号请求建立连接。 第二次：server接收后回复数据包（包括SYN，ACK，ack,seq）。 第三次：client接收后进行验证，如果正确将数据包返回给server，server确认后无误双方建立连接。 A和给B打电话。 拨通 A说喂，我是A，我找B。 B说哦，我是B，你说。 四次挥手步骤 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 client发送FIN关闭与server之间的数据传送。 server接收后发送ACK确认信号到client。 server发送一个FIN到client，关闭之间的数据传送 client收到FIN后，进入TIME_WAIT状态，并发送一个ACK给server，完成四次挥手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://Zhangbingwu.github.io/tags/TCP-IP/"}]},{"title":"MyBatis学习","slug":"MyBatis学习","date":"2019-07-29T16:00:00.000Z","updated":"2019-07-30T09:59:33.231Z","comments":true,"path":"2019/07/30/MyBatis学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/30/MyBatis学习/","excerpt":"","text":"MyBatis什么是MyBatis? MyBatis是数据库访问层框架，简化Dao层，提高开发效率。 框架和类库的差别? 类库：类似名言警句，直接拿来用。 框架：类似填空题，是软件开发的半成品。 使用 环境搭建 导入mybatis的jar包,和依赖jar包。 在src下建立mybatis.xml，全局环境配置，作用数据库的连接 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--可以有多个环境，default引用当前使用的--&gt;&lt;environments default=&quot;development&quot;&gt;&lt;!--声明可以使用的环境--&gt; &lt;environment id=&quot;development&quot;&gt;&lt;!--使用原生JDBC事务--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!-property的那么属性必须按照要求--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/库名?serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;数据库用户名&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;数据库密码&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 使UserMapper.xml配置生成的sql查询方法连接数据库 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/zbw/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; transactionManager标签的type属性可取值： JDBC，事务管理使用原生的JDBC管理模式。 MANAGED，将事务管理转交给其他容器，原生JDBC事务管理的setAutoMapping(false),设置为不自动提交。 dataSource标签type属性： POOLED，使用数据库连接池。 UNPOOLED，不适用数据库连接池，相当于直接使用JDBC。 JNDI：(java naming and directory interface)java命名目录接口技术，可以让java使用其他的如c语言编写的代码。 mybatis建议数据访问层命名mapper包,包下建立UserMapper.xml文件。作用：配置mybatis帮你生成一个a.b.selAll的方法，来执行你指定的sql语句。12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace:理解成实现类的全限定路径&quot;包名+类名&quot;--&gt;&lt;mapper namespace=&quot;a.b&quot;&gt;&lt;!-- id:方法名 paramType:方法的参数类型 resultType:方法的返回值类型。 如果方法的返回值类型是List，在resultType中写List的泛型， 因为mybatis对jdbc封装，一行一行读取数据。--&gt; &lt;select id=&quot;selAll&quot; resultType=&quot;com.zbw.pojo.User&quot;&gt; select * from users; &lt;/select&gt;&lt;/mapper&gt; 数据库连接池 Tomcat JDBC pool状态Active：当前连接对象被应用程序使用中Idle：空闲状态，等待应用程序使用 使用 在META-INF下创建context.xml。IDEA context.xml的配置内部参数： 1.JDBC连接 driverClassName=&quot;&quot; url=&quot;&quot; username=&quot;&quot; password=&quot;&quot; 2.数据库连接池的管理 maxActice=&quot;&quot; 最大正在使用的连接数量 maxIdle=&quot;&quot; 最大正在空闲的连接池内对象的数量 name=&quot;&quot; 该连接池的名称 auth=&quot;Container&quot; 数据库连接池交由应用程序还是服务器管理 maxWait=&quot;10000&quot; 最大等待时间10s type=&quot;javax.sql.DataSource&quot; 在java中通过name属性取到的数据库连接池，在java中的类型是什么123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt; &lt;Resource driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/sorm?serverTimezone=GMT&quot; username=&quot;root&quot; password=&quot;root&quot; maxActice=&quot;50&quot; maxIdle=&quot;20&quot; name=&quot;test&quot; auth=&quot;Container&quot; maxWait=&quot;10000&quot; type=&quot;javax.sql.DataSource&quot; /&gt;&lt;/Context&gt; 使用JNDI测试数据库连接池首先，既然设置了交由tomcat服务器管理，因此只有将项目发布至tomcat才能使用连接池。 12345Context context = new InitialContext(); //获取Context.xml对象DataSource ds = (DataSource) context.lookup(&quot;java:comp/env/test&quot;);//java:comp/env/固定字符串，完全实体，在context中寻找test连接池，返回DataSourceconn = ds.getConnection();//通过DataSource工厂获取连接。 DataSource 该工厂用于提供到此 DataSource 对象所表示的物理数据源的连接。作为 DriverManager 工具的替代项，DataSource 对象是获取连接的首选方法。实现 DataSource 接口的对象通常在基于 JavaTM Naming and Directory Interface (JNDI) API 的命名服务中注册。 DataSource 接口由驱动程序供应商实现。共有三种类型的实现：基本实现 - 生成标准的 Connection 对象连接池实现 - 生成自动参与连接池的 Connection 对象。此实现与中间层连接池管理器一起使用。分布式事务实现 - 生成一个 Connection 对象，该对象可用于分布式事务，大多数情况下总是参与连接池。此实现与中间层事务管理器一起使用，大多数情况下总是与连接池管理器一起使用。 三种查询方法statment为对应Mapper.xml中select的id。 selectList(String statment) 适用于 查询结果都需要遍历。 Mapper.xml中select标签的resultType（查询返回值类型）应该是集合中存储的对象，即集合的泛型，因为查询是一行一行的查，而每一行的数据就是一个对象。 selectOne(String statment) 返回值 Object 适用于 查询的是一行数据，或者一个变量。 如：select count(*) from table; 变量。 Mapper.xml中select标签的resultType（查询返回值类型）应该是内建的类型别名，帮助文档XML映射配置文件中typeAliases。 selectMap(String statment,String mapKey) 返回值Map(Object,OBject) 适用于 需求需要通过某一列的值快速查找这行数据的需求。 Mapper.xml中select标签的resultType（查询返回值类型）应该是Map中存储的值的类型。 把数据库中某一列的值当作map的key","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://Zhangbingwu.github.io/tags/MyBatis/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"https://Zhangbingwu.github.io/tags/数据库连接池/"}]},{"title":"Servlet 3.0 新特性","slug":"Servlet 3.0 新特性","date":"2019-07-27T16:00:00.000Z","updated":"2019-07-28T11:18:42.345Z","comments":true,"path":"2019/07/28/Servlet 3.0 新特性/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/28/Servlet 3.0 新特性/","excerpt":"","text":"Servlet 3.0 新特性参考至 1.Servlet异步处理支持 Servlet 3.0 之前，一个普通 Servlet 的主要工作流程大致如下：首先，Servlet 接收到请求之后，可能需要对请求携带的数据进行一些预处理；接着，调用业务接口的某些方法，以完成业务处理；最后，根据处理的结果提交响应，Servlet 线程结束。其中第二步的业务处理通常是最耗时的，这主要体现在数据库操作，以及其它的跨网络调用等，在此过程中，Servlet 线程一直处于阻塞状态，直到业务方法执行完毕。在处理业务的过程中，Servlet 资源一直被占用而得不到释放，对于并发较大的应用，这有可能造成性能的瓶颈。对此，在以前通常是采用私有解决方案来提前结束 Servlet 线程，并及时释放资源。 Servlet 3.0 针对这个问题做了开创性的工作，现在通过使用 Servlet 3.0 的异步处理支持，之前的 Servlet 处理流程可以调整为如下的过程：首先，Servlet 接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；接着，Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。如此一来， Servlet 线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回。 异步处理特性可以应用于 Servlet 和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet 和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下的方式启用： 开启异步支持 3.0注解也可以使用@WebServlet(name = &quot;Servlet&quot;,urlPatterns = &quot;/ser&quot;,asyncSupported = true) 对于使用传统的部署描述文件 (web.xml) 配置 Servlet 和过滤器的情况，Servlet 3.0 为 &lt;servlet&gt; 和 &lt;filter&gt; 标签增加了 &lt;async-supported&gt; 子标签，该标签的默认取值为 false，要启用异步处理支持，则将其设为 true 即可。以 Servlet 为例，其配置方式如下所示：12345&lt;servlet&gt; &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;footmark.servlet.Demo Servlet&lt;/servlet-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; 2.注解支持 1.@WebServlet name String 指定 Servlet 的 name 属性，等价于 &lt;servlet-name&gt;。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用。urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于 &lt;url-pattern&gt; 标签。 loadOnStartup int 指定 Servlet 的加载顺序，等价于 &lt;load-on-startup&gt; 标签。 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于 &lt;init-param&gt; 标签。 2.@WebInitParam name String 指定参数的名字，等价于 &lt;param-name&gt;。 value String 指定参数的值，等价于 &lt;param-value&gt;。 3.@WebFilter filterName String 指定过滤器的 name 属性，等价于 &lt;filter-name&gt; value String[] 该属性等价于 urlPatterns 属性。但是两者不应该同时使用。 urlPatterns String[] 指定一组过滤器的 URL 匹配模式。等价于 &lt;url-pattern&gt; 标签。 servletNames String[] 指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 &lt;servlet-name&gt; 的取值。 4.@WebListener value String 可不选 该监听器的描述信息。 5.@MultipartConfig辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持。该注解标注在 Servlet 上面，以表示该 Servlet 希望处理的请求的 MIME 类型(Multipurpose Internet Mail Extensions多用途互联网邮件扩展)是 multipart/form-data(指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思)。 HttpServletRequest 对文件上传的支持 Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件： Part getPart(String name) Collection getParts()前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：123Part photo = request.getPart(&quot;photo&quot;); photo.write(&quot;/tmp/photo.jpg&quot;); // 可以将两行代码简化为 request.getPart(&quot;photo&quot;).write(&quot;/tmp/photo.jpg&quot;) 一行。","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"Servlet学习05","slug":"Servlet学习05","date":"2019-07-27T16:00:00.000Z","updated":"2019-07-28T12:11:32.298Z","comments":true,"path":"2019/07/28/Servlet学习05/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/28/Servlet学习05/","excerpt":"","text":"Filter过滤器作用 对服务器接收的请求资源和响应给浏览器的资源进行管理。 保护Servlet。 使用步骤 实现javax.servlet.Filter 配置web.xml，类似servlet的配置1./* 过滤所有请求。2.*.do 对所有以.do结尾的请求过滤，一般是来进行模块拦截处理。3.具体的servlet的url-pattern过滤顺序从大到小，在符合条件的情况下，被大的过滤后进入小的过滤。 init() 在服务器启动时初始化。 doFilter()filterChain.doFilter(servletRequest,servletResponse);对请求放行。放行的请求抵达servlet,执行完servlet又会回到filterChain.doFilter()，才算执行完doFilter() ，类似方法的调用。 destroy() 服务器关闭时销毁 注意： 导包正确 javax.Servlet.Filter doFilter(servletRequest,servletResponse),注意参数不是HttpServletRequest,是其父类，可以(HttpServletRequest)servletRequest转型。 Listener监听器作用 对作用域对象进行监听，有点像事件机制。 对请求的监听 1.请求的创建和销毁需要实现ServletRequestListener requestInitialized() 初始化请求时 requestDestroyed() 请求销毁时 2.请求内容的更改需要实现ServletRequestAttributeListener attributeAdded() 新增的请求内容 attributeRemoved() 被移除的请求内容 attributeReplaced() 注意：保存的是被替换的请求的内容 srae.getName()srae.getValue() Session的监听 接口：HttpSessionListener 接口：HttpSessionAttributeListener application的监听 接口：ServletContextListener 接口：ServletContextAttributeListener","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Filter","slug":"Filter","permalink":"https://Zhangbingwu.github.io/tags/Filter/"}]},{"title":"Servlet学习04","slug":"Servlet学习04","date":"2019-07-26T16:00:00.000Z","updated":"2019-07-27T15:19:17.984Z","comments":true,"path":"2019/07/27/Servlet学习04/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/27/Servlet学习04/","excerpt":"","text":"EL表达式EL表达式的作用 可以获取servlet四个作用域中的数据 request session pageContext application 注意：不是获取servlet流转的数据，而是四个作用域中的数据。 使用 ${表达式}如果是请求参数 ${param.键名} ${paramValues.键名} 返回数组，例如爱好。 如果是setAttribute()存储的数据 ${键名}存储的式字符串返回字符串存储的对象返回对象 ${键名.属性名} 直接返回对象的属性值 ${list} 如果是List集合,返回数组${list[0]} 集合中第一个对象。 ${map.map的键名} 如果是Map集合，返回该map键名对应的值${map.get(键名)} EL表达式作用域查找顺序 如果请求数据中，不同作用域键名相同。EL表达式查找哪个？ 默认顺序：作用域从小到大找，小的里面没找到再去大的里面找，找到了后就不再继续查找。作用域从小到大：pageContext（当前页面）-&gt;request（一次请求）-&gt;session（一次会话）-&gt;application（服务器启动到关闭）注意：从小到大依次找。 指定顺序：想要EL表达式去指定的作用域查找怎么办？${pageScope.键名}${requestScope.键名}${sessionScope.键名}${applicationScope.键名} EL表达式还可以做简单的逻辑运算 加减乘除取余${1+2} — 3 判断${1&gt;2} — true${1==1} — true${1!=2} — true${1&lt;=1} — true 三目运算${sex==1?”男”:”女”} 注意： EL表达式中’+’号只有运算的作用，没有字符串连接作用,会报错。 ${1+”2”} 会将”2”转化为2，继续运算。 EL获取请求头数据和Cookie数据请求头数据 ${header} 取出所有请求头数据 ${header[“键名”]} 取出指定键名的请求头数据 ${headerValues[“键名”]} 取出指定键名(同键不同值)的请求头数组${headerValues[“键名”][0]} Cookie数据 ${cookie} 取出所有Cookie数据 ${cookie.键名} 获取这个Cookie对象1&#123;JSESSIONID=javax.servlet.http.Cookie@383b7293, Idea-51c8b0a1=javax.servlet.http.Cookie@2711011c&#125; 1JSESSIONID=B433435550B2EF7337CFFF3A6B21E581 JSTL标签使用之前 导jstl的jar包下载impl 设置page指令&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; jstl基本标签 &lt;c:out value=&quot;&quot; default=&quot;&quot; &gt;&lt;/c:out&gt;结合EL表达式&lt;c:out value=&quot;${str2}&quot; default=&quot;天天心情好&quot;&gt;&lt;/c:out&gt;作用：直接输出，如果为空，则输出默认值。 &lt;c:set var=&quot;键名&quot; value=&quot;键值&quot; scope=&quot;存储作用域&quot;&gt;&lt;/c:set&gt;类似于 作用域对象.setAttribute(“”,””)，默认存放在pageContext作用域 12&lt;c:set var=&quot;str&quot; value=&quot;我不好&quot; scope=&quot;request&quot;&gt;&lt;/c:set&gt;&lt;c:out value=&quot;$&#123;requestScope.str&#125;&quot;&gt;&lt;/c:out&gt; &lt;c:remove var=&quot;键名&quot; scope=&quot;存储作用域&quot;&gt;&lt;/c:remove&gt;类似于作用域对象.removeAttribute()注意：如果不指定作用域，会将四个作用域中符和键名的数据都删除。 jstl逻辑标签 单分支1234&lt;c:set var=&quot;score&quot; value=&quot;90&quot;&gt;&lt;/c:set&gt;&lt;c:if test=&quot;$&#123;score&gt;80&#125;&quot;&gt; &lt;u&gt;干得漂亮！&lt;/u&gt; &lt;/c:if&gt; 配合EL逻辑表达式，因此表达式值必须是四个作用域中的。 多分枝1234567891011&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;fruit==&apos;apple&apos;&#125;&quot;&gt; &lt;b&gt;苹果！&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;fruit==&apos;banana&apos;&#125;&quot;&gt; &lt;i&gt;香蕉！&lt;/i&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;b&gt;蔬菜！&lt;/b&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; jstl的循环标签(常用) 常量循环12345&lt;c:forEach begin=&quot;0&quot; end=&quot;3&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt; &lt;c:if test=&quot;$&#123;vs.index&lt;=2&#125;&quot;&gt; 哥哥，你真猛！---$&#123;vs.index&#125;---$&#123;vs.count&#125;&lt;br&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; step:步数，默认为1.varStatus:在作用域中存储了每一次循环的数据(角标，次数，是否第一次循环，是否最后一次循环) 动态循环List集合：123&lt;c:forEach items=&quot;$&#123;requestScope.list&#125;&quot; var=&quot;v&quot;&gt; $&#123;v&#125;&lt;br&gt; &lt;/c:forEach&gt; Map集合： 123&lt;c:forEach items=&quot;$&#123;requestScope.map&#125;&quot; var=&quot;m&quot;&gt; $&#123;m&#125;---$&#123;m.key&#125;---$&#123;m.value&#125;&lt;br&gt; &lt;/c:forEach&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"},{"name":"EL表达式","slug":"EL表达式","permalink":"https://Zhangbingwu.github.io/tags/EL表达式/"},{"name":"JSTL标签","slug":"JSTL标签","permalink":"https://Zhangbingwu.github.io/tags/JSTL标签/"}]},{"title":"Servlet学习03","slug":"Servlet学习03","date":"2019-07-25T16:00:00.000Z","updated":"2019-07-27T03:22:03.925Z","comments":true,"path":"2019/07/26/Servlet学习03/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/26/Servlet学习03/","excerpt":"","text":"Ajax学习什么是Ajax? 局部刷新技术Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），用来在当前页面内响应不同的请求内容。 Ajax并非一种新的技术，而是几种原有技术的结合体，是浏览器端的技术。 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 Ajax运行原理 参考至 在JS中，通过XMLHttpRequest对象向服务器异步发送请求，获取响应数据，通过JS操作文档结构，达到更新数据的展示。 Ajax采用异步请求，虽然同步效率高于异步，但是通过异步请求，不会阻塞用户，可以达到无刷新更新数据的效果。 Ajax的使用 1.获取Ajax对象 因为浏览器版本的问题判断。 2.重写onreadystatechange函数 判断Ajax状态码判断响应状态码 获取响应内容 处理响应内容(操作文档结构) 3.发送请求 示例1234567//创建Ajax引擎对象 var xmlHttp; if(window.XMLHttpRequest)&#123; //火狐等 xmlHttp = new XMLHttpRequest(); &#125;else if(window.ActiveXObject)&#123; //IE低版本 xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlHttp.onreadystatechange = function () {} //重写onreadystatechange函数 xmlHttp.readyState Ajax状态码(0,1,2,3,4)0:建立了ajax对象，但是还未初始化1:ajax对象创建 open()调用2:send()调用3:请求成功发送，正在接收数据4:接收数据成功 xmlHttp.status 响应状态码12xmlHttp.open(&quot;get&quot;,&quot;a&quot;,true); // (&quot;请求方式&quot;,&quot;uri&quot;,&quot;是否开启异步&quot;)xmlHttp.send(null); //post请求的话，用来发送请求参数。 Ajax的异步和同步默认为true：开启异步 同步：Ajax发送请求后，等待数据接收后，再继续执行接下来的代码。 异步：Ajax发送请求后，开辟一个线程去等待接收，与此同时继续执行接下来的代码。 Ajax请求方式 get方式 12xmlHttp.open(&quot;get&quot;,&quot;a?name=杨二&amp;pwd=321&quot;,true);xmlHttp.send(null); post方式 123xmlHttp.open(&quot;post&quot;,&quot;a&quot;,true);xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlHttp.send(&quot;name=张三&amp;pwd=123&quot;); post方式必须要有，设置参数类型是键值对。xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”); Ajax响应JSON 在处理Ajax请求，响应数据的时候，如果数据是对象，或者装有对象的集合。 分析 要将对象完整的传输，可以用js的对象存储已有的对象 json格式：响应数据：var obj={“name”:”zhangsan”,”pwd”:”123”} 在js中使用Global.eval()方法，检查并执行内部代码，Global可以省略，js中便创建了相同内容的对象。 但是后台不应该规定对象名，所以直接响应： {“name”:”zhangsan”,”pwd”:”123”} 在js中eval(“var obj2=”+ajax对象.responseText); 为了方便，不用自己拼接字符串，可以使用Gson可以将对象，集合自动转为json格式。resp.getWriter().write(new Gson().toJson(h)); List的话 Gson会转为[{},{},{}···] 这样的数组 XML 接收ajax请求的servlet必须设置响应编码格式。resp.setContentType(&quot;text/xml;charset=utf-8&quot;); ajax接收时。12var doc = xmlHttp.responseXML;alert(doc.getElementsByTagName(&quot;name&quot;)[0].innerHTML);","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"},{"name":"Ajax","slug":"Ajax","permalink":"https://Zhangbingwu.github.io/tags/Ajax/"}]},{"title":"Servlet路径问题","slug":"Servlet路径问题","date":"2019-07-24T16:00:00.000Z","updated":"2019-07-25T16:06:20.124Z","comments":true,"path":"2019/07/25/Servlet路径问题/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/25/Servlet路径问题/","excerpt":"","text":"Servlet重定向路径相对路径 从当前请求的路径查找资源的路径 问题：如果Servlet的别名中包含目录，会造成重定向失败。 绝对路径 第一个/表示服务器根目录，weboot /虚拟项目名/资源路径 Servlet请求转发相对路径 从当前请求的路径查找资源的路径 问题：如果Servlet的别名中包含目录，会造成请求转发失败。 绝对路径 第一个/表示项目根目录 /资源路径","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"JSP运行原理","slug":"JSP运行原理","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-24T05:55:20.703Z","comments":true,"path":"2019/07/24/JSP运行原理/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/JSP运行原理/","excerpt":"","text":"运行原理是为了书写HTML方便而产生的，html文件通过处理，逐行读取并加上resp.getWriter().writer(),就成为了服务器认识的Servlet。 通过tomcat下web.xml中公共配置可以发现： 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt; 找到org.apache.jasper.servlet.JspServlet这是转译后的jspServlet 123public final class jspPro_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; 这是里面的_jspService方法 12public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; 找到org.apache.jasper.runtime.HttpJspBase反编译后： 1public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123; 发现其父类继承了HttpServlet，再看他的service方法 123456@Overridepublic final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123; _jspService(request, response);&#125; 其又调用了HttpJspBase中_jspService方法。 1234567891011out.write(&quot;\\r\\n&quot;);out.write(&quot;\\r\\n&quot;);out.write(&quot;&lt;!--\\r\\n&quot;);out.write(&quot; JSP的三种注释：\\r\\n&quot;);out.write(&quot; 1.前端语言注释：\\r\\n&quot;);out.write(&quot; 会被转译，会被发送，不会被浏览器执行\\r\\n&quot;);out.write(&quot; 2.java语言注释：\\r\\n&quot;);out.write(&quot; 会被转译，不会被Servlet执行\\r\\n&quot;);out.write(&quot; 3.JSP注释：\\r\\n&quot;);out.write(&quot; 不会被转译\\r\\n&quot;);out.write(&quot;--&gt;&quot;); 里面的方法类似resp.getWriter().writer(),只是进行了封装。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Zhangbingwu.github.io/categories/随笔/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://Zhangbingwu.github.io/tags/JSP/"}]},{"title":"ServletContext在案例中使用空指针问题","slug":"ServletContext在案例中使用空指针问题","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-23T16:51:23.089Z","comments":true,"path":"2019/07/24/ServletContext在案例中使用空指针问题/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/ServletContext在案例中使用空指针问题/","excerpt":"","text":"ServletContext在案例中使用问题ServletContext在案例中使用简单的网站案例，添加网站访问次数计数器，ServlertContext实现不同用户共享访问次数信息，并更改，从而达到网站访问计数器功能，功能实现没有问题，但是由于ServletContext生命周期从服务器开启到关闭，访问次数信息需要保存到外部文档中，因此在服务器启动，和服务器关闭时加入流操作，获取和存储访问次数信息，从而达到服务器重启后访问次数存在。 问题 服务器每次关闭都会报空指针错误，没有具体指明错误代码，因此我觉得时destroy()方法中出现的错误。 出现空指针异常，审查过后只有一处可能出现。String nums = (Sting)this.getServletContext().getAttribute(&quot;nums&quot;)是否因为获取的nums次数为null，由于强转引起的空指针问题？并且通过简单的System.out.println(nums);确定了是此处问题。 既然是强转出问题，不确定获得的nums是否为null，我用Object nums = this.getServletContext().getAttribute(&quot;nums&quot;)并输出nums值发现不为null，因此排除了null可能，但是也发现这种方法没有报错。 最终怀疑是否(String)强转的问题，我改用String nums = String.valueOf(this.getServletContext().getAttribute(&quot;nums&quot;));的方式，问题得以解决。","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"Servlet学习02","slug":"Servlet学习02","date":"2019-07-23T16:00:00.000Z","updated":"2019-07-27T12:14:16.973Z","comments":true,"path":"2019/07/24/Servlet学习02/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/24/Servlet学习02/","excerpt":"","text":"JSP学习JSP基本概念和运行原理 JSP基本概念JSP(java server pages),中文全称：java服务器页面,其根本是一个简化的Servlet设计，由sun公司倡导，许多公司参与一起建立的一种动态网页技术标准。（动态在于数据的动态） 特点 本质还是Servlet 跨平台，一次编写处处运行。（java） 组件跨平台 健壮性和安全性 运行原理见JSP运行原理。 JSP的page指令学习书写&lt;@ page 属性名=”” 属性名=”” 属性名=””…..&gt;属性之间空格隔开。 常见属性 1.import声明转译后的java文件要导入的包。 2.language声明JSP要转译成的语言。 3.pageEncodingJSP文件保存格式。 4.contentTypejsp数据响应给浏览器，浏览器的解析和编码格式。 5.errorPage设置jsp运行错误跳转页面 6.entends设置java文件要继承的父类（包名+类名） 7.session设置转译的servlet是否开启session支持，默认开启。 代码块 1.JSP的局部代码块：&lt;% %&gt;在_JspService()方法中。 2.JSP的全局代码块：&lt;%! %&gt;在方法外，全局的。 3.JSP的脚本段代码块：&lt;%= %&gt;相当于：out.write(); =之后写的就在括号内部。 缺点逻辑判断困难，阅读困难，尽量将业务处理，和页面展示分开。 静态引入＆动态引入 静态引入 &lt;%@ include file=&quot;相对路径&quot;&gt; 不会生成JspServlet文件 将两个jsp合并到后生成JspServlet 因此不能使用同名变量 动态引入 &lt;jsp:include page=&quot;相对路径&quot;&gt;&lt;/jsp:include&gt; 会生成JspServlet文件 能使用同名变量 优点降低代码冗余，便于维护升级。 请求转发forward标签 作用类似Servlet的请求转发，req.getRequestDispatcher(“”); 特点 一次请求 地址栏信息不改变 使用&lt;jsp:forward page=&quot;forward.jsp&quot;&gt;&lt;/jsp:forward&gt; 注意内部不允许任何字符，除了它的子标签&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;,子标签用于数据的流转，实现是 forward?name=value 请求参数拼接。 九大内置对象：service方法中自动声明的。 Request Response config：ServletConfig，获取每个Servlet单独的配置信息。 session：用户不同请求间数据共享。一次会话。 application：ServletContext，一个Servlet只能有一个，不同用户共享。 pageContext：封存了其他八个对象 page：类似于java中的this 代表这个Servlet out：响应对象，JSP内部使用，带有缓冲区的响应对象，效率高于Response。（不能做一些类似设置响应头的工作） exception：异常对象，存储了当前运行异常信息。（注意：需要在page指令中isErrorPage=”true”开启） jsp绝对路径 /虚拟项目名/资源路径第一个/代表web项目，Localhost：8080/","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://Zhangbingwu.github.io/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"intellij idea在运行web项目时部署的位置(tomcat)","slug":"intellij idea在运行web项目时部署的位置(tomcat)","date":"2019-07-22T16:00:00.000Z","updated":"2019-07-23T05:05:22.643Z","comments":true,"path":"2019/07/23/intellij idea在运行web项目时部署的位置(tomcat)/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/23/intellij idea在运行web项目时部署的位置(tomcat)/","excerpt":"","text":"别的 今天好奇IDEA中web项目是怎么通过tomcat运行的？原因在于MyEclipse中web项目在tomcat中webapps目录下以其虚拟项目名创建的目录中有着运行所需要的webroot目录，那么IDEA中web项目在tomcat的哪里呢？通过百度了解到了相关知识。 具体参见 war exploded和war包 war exploded模式（开发模式）是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。On’Updata’action 和 On frame deactivation都改成Update resources。 war包则是项目发布常用的模式。 intellij idea在运行web项目时部署的位置(tomcat) A-首先实际运行的位置在项目所在目录\\out\\artifacts\\项目名_war_exploded下 B-tomcat中运行的是根据${user.home}/.IntelliJIdea/system/tomcat/项目名/conf/Catalina/localhost下的xml文件找到实际运行的位置即A中。可以在IDEAtomcat配置里Deployment更改Application context项目虚拟名，从而修改启动的URL，这在B目录下的xml文件中可以体现","categories":[{"name":"问题","slug":"问题","permalink":"https://Zhangbingwu.github.io/categories/问题/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://Zhangbingwu.github.io/tags/IDEA/"}]},{"title":"","slug":"web项目中数据库加载驱动ClassNotFound","date":"2019-07-21T16:19:09.741Z","updated":"2019-07-24T07:57:23.297Z","comments":true,"path":"2019/07/22/web项目中数据库加载驱动ClassNotFound/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/22/web项目中数据库加载驱动ClassNotFound/","excerpt":"","text":"title:IDEAweb项目中数据库加载驱动ClassNotFoundweb项目中数据库加载驱动ClassNotFound通过报错信息确定dao层数据库连接查询的问题,控制台报错com.mysql.cj.jdbc.Driver ClassNotFoundException,发现是数据库连接jar包所在的lib文件夹位置的问题。 解决导入数据库连接jar包到web-&gt;WEB-INF-&gt;lib文件夹下。 补充（7-23）此种模式称为war exploded模式（开发模式）直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。","categories":[],"tags":[]},{"title":"","slug":"MVC思想","date":"2019-07-21T16:18:55.039Z","updated":"2019-07-24T07:56:44.577Z","comments":true,"path":"2019/07/22/MVC思想/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/22/MVC思想/","excerpt":"","text":"title:MVC思想MVC思想 参考至 MVC（Model View Controler）模型，视图，控制器 视图作用于用户，一种用户用来操作的界面，浏览器，程序页面等以便于用户输入信息。 控制器控制器接受用户的输入并调用模型和视图去完成用户的需求 模型业务逻辑模型，具体的分析数据，实现业务。 流程根据用户输入信息或发送的请求，调用对应的业务层接口，业务层通过调用dao层操作数据库获取信息，信息反馈给业务层，业务层根据信息不同响应用户不同的展示。 其他 Servlet接受请求，用户数据 service（业务层）定义接口，检查是否有用户信息，并返回用户信息的实体类 pojo存储用户信息的实体类 dao层，（数据库连接层）数据库层的接口，将用户信息和数据库比较，实现具体的业务JDBC步骤： 声明JDBC对象 加载驱动 获取连接 创建Sql命令 创建Sql命令对象 给占位符赋值 执行 遍历执行结果 关闭资源 返回 数据库存储用户信息","categories":[],"tags":[]},{"title":"Http协议学习","slug":"Http协议学习","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-30T07:30:22.090Z","comments":true,"path":"2019/07/20/Http协议学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Http协议学习/","excerpt":"","text":"了解Http什么是Http？ 全称Hyper Text Transfer Protocol（超文本传输协议） 作用1.用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。2.是对服务器和客户端交流的格式规范。3.没有http协议也可以达到交流的目的,但是影响推广。 Http工作原理 HTTP是一个基于TCP/IP通信协议族来传递数据（HTML 文件, 图片文件, 查询结果等）。 https://www.jianshu.com/p/9f3e879a4c9c HTTP默认端口号为80 HTTP特点 简单快速发送请求时，只需要传送请求方法和路径。请求方法常用的有：GET,POST,HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单,使得HTTP服务器的程序规模很小,因而通信速度块。 媒体独立服务器可以接受客户端发送的任何类型的数据,并用content-type对正文内容类型加以标记。 无连接无连接的含义是限制每次连接只处理一个请求。客户端请求,服务器处理并相应,收到客户端应答后连接断开。这种方式可以节省传输时间。注意:HTTP 1.1 后支持持续连接。 无状态服务器每次接受到请求后,处理响应,但是不会记忆请求信息,如果需要第二次请求,即使内容相同也要重新发送请求信息,这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。联想填寄快递单。 HTTP交互流程 客户端与服务器建立连接。 客户端向服务端发送请求。 服务端接受处理请求,做出响应。 关闭客户端与服务器的连接。(HTTP1.1之后不会立即关闭) HTTP消息结构请求消息请求头:请求方式 URL 协议版本。 请求行:消息报头,一般用来说明客户端需要使用的一些附加信息。 空行:必须要有。 请求主体响应消息状态行:协议版本,状态码,状态描述。 响应头:消息报头,客户端使用的附加信息,时间,conten-type,content-length。 空行:必须要有 响应正文不同的请求方式,消息结构会有一些差异。 GET方式没有请求主体,直接以？隔开拼接在请求地址后。 HTTP请求方式GET请求方式 特点 get方式只能传输少量数据,不是因为http协议,而是因为地址栏长度有限制。 没有请求主体,直接以？隔开拼接在请求地址后。 不安全,因为请求信息暴露。 效率高。 POST请求方式 特点 POST方式可以传输大量数据。 请求信息可以都放在请求主体中,也可以拼接在请求地址后,可以合在一起用。 安全。 效率相比GET低。 不同请求方式使用 第一衡量指标：安全 然后考虑数据量。 状态码状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用HTTP状态码共分为5种类型： 1** 信息 2** 成功 3** 重定向 4** 客户端错误 5** 服务器错误 常见状态码 200 OK //客户端请求成功 400 BadRequest //客户端请求有语法错误 401 Unauthorized //请求未经授权 403 Forbidden //服务器拒绝提供服务 404 Not Found //请求资源不存在 500 Internal Server Error //服务器发生了不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端请求,一段时间后会恢复","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://Zhangbingwu.github.io/tags/Http/"}]},{"title":"Servlet学习01","slug":"Servlet学习01","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-23T16:32:32.595Z","comments":true,"path":"2019/07/20/Servlet学习01/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Servlet学习01/","excerpt":"","text":"服务器什么是服务器？ 可以实时地调用不同的代码的一个容器。 Servlet技术Servlet概念 Server AppletServlet（Server Applet）：全称Java Servlet。是基于Java技术的web组件，由容器管理并产生动态内容。Servlet引擎作为WEB服务器的扩展提供支持Servlet功能。Servlet与客户端通过Servlet容器实现的请求/响应模式进行交互。动态web开发技术。 为什么有Servlet技术？ 服务器接收到浏览器请求后,自动调用对应逻辑代码进行请求处理,但是逻辑代码是有程序员编写并放到服务器中,那么服务器怎么知道该怎么调用？调用哪个类？哪个方法进行请求处理？ 程序员在编写代码的时候能够按照服务器能够识别的规则进行编写,浏览器按照指定的规则进行发送请求,那么服务器就可以调用并执行相应逻辑的代码进行请求处理。 狭义的Servlet是指Java实现的一个接口 通过实现这个接口从而规范代码书写。 广义的Servlet是指任何实现了这个接口的类 一般人们理解为广义的。 使用IDEA配置和使用Tomcat IDEA配置和使用Tomcat 步骤 1.类需要继承HttpServlet其父类实现了Servlet接口,保证了规范。 2.重写方法 3.方法中书写逻辑代码 4.在webRoot下的WEB-INF文件夹下的web.xnml文件中配置servlet 组成如http://localhost:8080/project/test服务器地址:端口/虚拟项目名/Servlet别名 Servlet生命周期具体过程1.启动web服务器解析web.xml 2.第一次接收到客户端请求,服务器判断Servlet实例是否存在，加载Servlet并创建实例 3.init()并调用请求相应方法 4.等待其他请求 5.服务器关闭,Servlet销毁,destroy()1.从第一次接收到请求,到服务器关闭2.如果web.xml配置了load-on-startup,生命周期从服务器启动,到服务器关闭。service()和doGet()和doPost()service()可以处理get/post方式的请求,如果servlet中有service方法,会优先调用service方法对请求进行处理。doGet()处理get方式的请求doPost()处理post方式的请求注意*如果在重写的service方法中调用了父类的service方法(super.service(req, resp);),则service方法处理完后,会再次根据请求方式相应的doGet和doPost方法。所以,一般情况下,我们是不在重写的service中调用父类的service方法的,避免出现405错误(请求方式不匹配)*Servlet常见错误404错误：资源未找到 请求地址中虚拟项目名以及Servlet别名检查是否与web.xml匹配。 500错误：内部服务器错误 ClassNotFoundException:com.xxx.xxx检查web.xml中Servlet类的全限定路径是否错误servlet-class service方法体代码逻辑错误。 405错误：请求方式不支持 检查get和post请求方式是否有匹配的doGet和doPost 一般使用service方法且不要调用父类 Request对象什么是Request对象？服务器接受到请求后,需要存储请求,并保证请求数据的完整性,因此创建一个对象来保存,在service方法执行时作为实参传递到service方法中。获取请求数据 获取请求头数据 req.getMethod() //获取请求方式 req.getRequestURL() //获取请求URL req.getRequestURI() //获取请求URI URI就是具体的资源路径 req.getScheme() //获取请求协议信息 获取请求行数据 req.getHeader(“键名”) //获取指定的附加信息 req.getHeaderNames() //获取所有的附加信息的键名 返回枚举类型12345678Enumeration&lt;String&gt; names = req.getHeaderNames(); //返回枚举类型 //遍历枚举 while(names.hasMoreElements())&#123; String name = names.nextElement(); //根据键名查询值 String value = req.getHeader(name); System.out.println(name+value); &#125; 获取请求主体 req.getParameter(“键名”) //获取指定的用户数据 req.getParameterValues(“键名”) //获取同名不同值的用户数据 返回数组 req.getParameterNames() //获取所有的用户数据的键名 返回枚举类型 注意如果键名匹配出现问题,返回null,因此需要注意空指针问题。 Request对象作用域 解决了不同的Servlet之间数据共享问题，也就是数据能从一个Servlet流转到另一个Servlet中。 使用：req.setAttribute(object name,object value);req.getAttribute(object name); //根据类型不同强转 作用域基于请求转发，一次请求内的所有Servlet有效。 Request对象特点 服务器创建 每次请求都会创建（http的无状态） 生命周期–一次请求（基于请求转发） Response对象作用对请求做出响应设置响应数据 设置响应头 resp.setHeader(String name,String name); //会覆盖掉原来的 resp.addHeader(String name,String name); //会继续添加 设置响应编码格式resp.setHeader(“content-type”,”text/html;charset=utf-8”);resp.setContentType(“text/html;charset=utf-8”); 设置响应状态resp.sendError(int num,String msg); 设置响应实体esp.getWriter().write(String content); 请求中文乱码解决1.使用String进行数据重新编码uname = new String(uname.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);2.使用公共配置 get方式 req.setCharacterEncoding(“utf-8”); tomcat的目录下的配置文件conf目录中修改server.xml,在connector标签下添加属性，useBodayEncodingForURI=”true”; post方式req.setCharacterEncoding(“utf-8”); 注意 useBodyEncodingForURI=”true”是说，请求参数的编码方式要采用请求体的编码方式。 而filter的request.setCharacterEncoding(‘UTF-8’)或者请求header中的content-type中的编码都是针对请求体的。 URIEncoding是针对请求参数的编码设置的。 请求转发 作用实现多个Servlet联动操作处理请求，这样避免了代码冗余，让Servlet职责更加明确。 使用req.getRequestDispatcher(“要转发的地址”).forward(req,resp);地址：相对路径，直接书写Servlet别名。 特点一次请求，浏览器地址信息不会变化。 注意请求转发后直接return，交由其他Servlet来响应。 响应重定向 解决了表单重复提交的问题，以及此Servlet无法处理请求的的问题 使用： resp.sendRedirect(String uri);如果是网络资源String url 实例： resp.sendRedirect(&quot;/login/m&quot;); 特点 两次请求，两个request 浏览器地址信息会发生变化，因为请求不同。 使用时机 如果请求中由表单数据（由form表单收集的用户信息）且比较重要不能重复提交，建议使用重定向。 如果这个Servlet无法处理此请求，建议使用重定向定位到可以处理的资源。（如：淘宝购买商品，购买后淘宝定向到支付宝） CookieCookie的作用和特点 作用解决发送的不同请求间的数据共享问题。 特点 临时存储如果没有设置Cookie有效期，那么这个Cookie对象为临时存储，存储在浏览器的运存中，重新打开浏览器Cookie对象失效。 定时存储设置Cookie有效期后，这个Cookie对象为定时存储，存储在客户端硬盘中，在有效期内符和路径要求的请求都会附带该信息。 浏览器端的数据存储技术。 存储数据的声明在服务器端。 注意： 一个Cookie对象只能存储一条数据,以键值对的形式存储。 Cookie的使用 Cookie的创建，设置和响应 创建Cookie对象Cookie ck = new Cookie(&quot;uname&quot;,&quot;zhangsan&quot;); 设置Cookie有效期–以s为单位的intck.setMaxAge(2*24*3600); 设置Cookie有效路径–urick.setPath(&quot;/cookie/abc&quot;);只有访问这个路径，请求才会携带cookie信息 响应Cookie信息到浏览器resp.addCookie(ck); Cookie的获取 Cookie[] cks = req.getCookies();返回一个由Cookie对象的数组。 注意：如果Cookie中没有数据，获取的cks为null，如果遍历获取内容出现空指针问题。1234567if(cks != null)&#123; for(Cookie ck:cks)&#123; String name = ck.getName(); String value = ck.getValue(); System.out.println(name+&quot;:&quot;+value); &#125;&#125; 为什么要进行Cookie校验例子：用户登录成功，创建Cookie对象，（！注意，Cookie对象的创建，因为Cookie直接在响应头和请求头中，不要涉及密码等隐私，安全问题。）如果不进行校验，用户注销（数据库中删除了用户数据），用户再次登录就会发生问题。 Session技术Session作用及其原理 作用解决了用户发起的不同请求，服务器在对不同请求处理时用户请求信息的共享。 原理用户登录成功后，服务器为其创建一个session对象，用于存储用户的信息，方便以后使用。而怎么让用户第二次请求时拿到正确的session对象？服务器创建session对象后，将对应的JSESSIONID（类似于号码牌，对应其session对象）利用Cookie技术存储到浏览器中，那么请求时通过这个ID就能找到对应的session对象，从而使不同请求可以调用session对象来共享数据。 Session的使用创建Session/获取Session对象`HttpSession hs = req.getSession();` 注意：创建还是获取，依据于请求中是否有session的标识符JSESSIONID，有就返回对应的session对象，没有就创建新的session对象，并将JSESSIONID作为Cookie数据存储在浏览器运存中。（所以只要重启浏览器就会丢失Cookie数据即JSESSIONID，临时存储，session对象存储在服务器中） 设置session存储时间（默认存储时间：30min）hs.setMaxInactiveInterval(int seconds);注意：在指定时间内session对象没有被使用则销毁，指定时间内使用了就会重新计时。 设置session立即销毁hs.invalidate(); session存储/获取数据 存储和获取 存储：hs.setAttribute(String name,Object value);可以存放对象。 获取：String name = (String) hs.getAttribute(&quot;name&quot;);返回Object类型需要强转。 注意：存储的动作和去除的动作发生在不同的请求中，但是存储要先于取出执行。 使用时机：一般用户在登录web项目时会将用户的个人信息存储Session中，供其他请求使用。 Session的特点 1.依赖于Cookie技术 2.生命周期为：一次会话JSESSIONID存储在Cookie的临时存储空间中，即浏览器运存中，浏览器关闭就会失效。 3.默认存储时间30min Session的作用域 一次会话 当浏览器JSESSIONID和服务器的SESSION对象都未失效时，作用于整个web项目中。 Session的失效处理 判断浏览器JSESSIONID和服务器的JSESSIONID是否一致。 判断根据浏览器JSESSIONID拿到的session对象数据是否为null。 ServletContext对象的学习基本概念 作用解决了不同用户之间数据的共享问题。 原理类似session对象的原理，服务器创建一个对象，不同的是所有的用户都可以获取并使用。 特点 用户共享 服务器创建 作用域整个项目内。 生命周期服务器启动到服务器关闭。 ServletContext的使用 1.获取ServletContext对象，三种获取方式 ServletContext sc = this.getServletContext(); ServletContext sc2 = this.getServletConfig().getServletContext(); ServletContext sc3 = req.getSession().getServletContext();注意：这三种方式创建的ServletContext对象都是同一个。 2.ServletContext存储数据/获取数据 存储sc.setAttribute(String name,Object value); 获取,返回Object类型Object o = sc.getAttribute(String name); 3.全局参数的设置及获取 web.xml中全局数据配置 1234&lt;context-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;zhangsan&lt;/param-value&gt; &lt;/context-param&gt; 获取web.xml全局配置数据sc.getInitParameter(user);返回对应的值String类型。sc.getInitParameterNames();返回获取web.xml全局配置数据键名的枚举。作用：将静态数据和代码解耦。 3.获取项目webroot下资源的绝对路径String path = sc.getRealPath(&quot;/doc/1.txt&quot;);path为项目根目录补全后的绝对路径。 4.获取项目webroot下资源的流对象InputStream is = sc.getResourceAsStream(&quot;/doc/1.txt&quot;);注意：此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取。 ServletConfig对象学习作用 获取web.xml给每个Servlet单独的配置信息 使用 给每个Servlet单独的配置 1234&lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; 获取ServletConfig对象ServletConfig sc = this.getServletConfig(); 获取servlet配置信息String code = sc.getInitParameter(&quot;config&quot;); server.xml大体组件内容1234567891011&lt;Server&gt; &lt;Service&gt; //可以配置多个Service &lt;Connector /&gt; //端口 可以有多个端口 &lt;Connector /&gt; &lt;Engine&gt; //引擎 一个Service只能有一个 &lt;/Host&gt; &lt;context /&gt; //热部署配置 &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 热部署&lt;Context path=&quot;/项目别名&quot; reloadable=&quot;true&quot; docBase=&quot;项目所在绝对路径&quot; /&gt;注意：如果需要映射的docBase下的文件被删除，服务器启动会报错，而冷部署如果webapps下没有，服务器启动也不会报错。 总结 Servlet使用流程 设置请求编码格式 通用方式（String编码） 公共配置：get请求数据在请求参数中，和post请求数据在请求体中。 设置响应编码格式 resp.setContentType(&quot;text/html;charset=utf-8&quot;); 获取请求数据 获取Cookie数据 Cookie[] cks = req.getCookies();返回有Cookie对象的数组，遍历注意空指针问题。 Session优化 ServletContext优化 获取用户信息 String uname = req.getParameter(&quot;uname&quot;); 处理请求数据 获取业务层对象，调用业务层方法。 响应处理结果 直接响应 resp.getWriter().writer(&quot;&quot;); 请求转发 req.getRequestDispatcher(&quot;servlet别名&quot;).forward(req,resp); 响应重定向 resp.sendRedirect(&quot;servlet的uri&quot;);","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://Zhangbingwu.github.io/tags/Servlet/"}]},{"title":"jQuery的学习","slug":"jQuery的学习","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-30T04:21:05.942Z","comments":true,"path":"2019/07/19/jQuery的学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的学习/","excerpt":"","text":"jQuery的选择器学习 1.基本选择器- 1.id $(&quot;#id&quot;); - 2.标签名 $(&quot;标签名&quot;); - 3.类 $(&quot;.类名&quot;); 如:$(&quot;.common&quot;); - 4.全部 $(&quot;*&quot;); - 5.组合 如：$(&quot;id,标签名,····&quot;); -注意：jQuery选择器返回的是装有元素对象的数组。id选择器是装有一个对象的数组。2.层级选择器1.ancestor descendant 祖先 后代 $(&quot;祖先 后代 &quot;) 2.parent &gt; child :在给定的父元素下匹配所有的子元素 $(&quot;form &gt; input&quot;) 注意：只有子元素，孙子元素不能。 3.prev + next :匹配所有紧接在 prev 元素后的 next 元素 $(&quot;label + input&quot;)注意：这里是紧接的，也就是下一个！ 4.prev ~ siblings :匹配 prev 元素之后的所有 siblings 元素 $(&quot;form ~ input&quot;) 注意：找到所有与表单同辈的 input 元素3.简单选择器对获得的对象数组进一步过滤，从而得到需要的对象。 如：&apos;$(&quot;li:first&quot;);&apos;所有li标签对象数组中的第一个。 &apos;$(&quot;li:not([class])&quot;);&apos;所有li标签对象数组中不包含class属性的 :even,:odd 索引的奇偶判断 :eq(index);索引为index的对象 :gt(index);索引为index以后的对象 :it(index);索引为index以前的对象 :header; h1,h2,h3之类的标题元素4.属性选择器$(&quot;input[id=&apos;1&apos;]&quot;); != 不为某些值;^= :以某些值开头;$= ：以某些值结尾;*= ：包含某些值 多个合一块用：$(&quot;input[id],name=&apos;zs&apos;&quot;);5.表单选择器:表单元素 选择该类表单元素的对象数组。 如： $(&quot;:text:eq(0)&quot;) form表单中 type属性为text的第一个对象。6.内容选择器$(&quot;b:contains(&apos;你好&apos;)&quot;);b标签中的值是‘你好’的b标签元素对象数组。 $(&quot;div:has(p)&quot;);所有包含p标签的div标签元素对象数组。7.可见性选择器:visible 可见的标签 :hidden 不可见的标签jQuery操作元素属性:1.获取属性对象数组.attr(&quot;&quot;); 注意：对象数组.attr(&quot;value&quot;);只能获得默认的值，不能动态更新， 类似自定义属性的getAttribute();可以使用 对象数组.val();2.修改属性对象数组.attr(&quot;类型&quot;,&quot;新值&quot;);jQuery操作元素内容1.获取元素内容对象数组.html(); 对象数组.text(); 两者的区别同innerHTML和innerText一样。2.修改元素内容对象数组.html(&quot;新内容&quot;); 对象数组.text(&quot;新内容&quot;); 两个都会覆盖原有内容。jQuery操作元素样式:1.对象数组.css();- 对象数组.css(&quot;width&quot;); 获取width值 - 对象数组.css(&quot;属性名&quot;,&quot;属性值&quot;); - json方式 对象数组.css({&quot;&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;,···}); 不同样式之间逗号隔开 如：`div02.css({&quot;height&quot;:&quot;300px&quot;,&quot;width&quot;:&quot;300px&quot;,&quot;border&quot;:&quot;solid 1px black&quot;});`2.对象数组.addClass(“类名”);- 对象数组.addClass(&quot;类名1 类名2&quot;); 不同类之间 空格隔开#jQuery操作文档结构: 1.内部插入：1.append() 追加 2.appendTo() 将元素对象追加到指定的元素对象中，并删除该元素对象。 3.prepend() 追加到之前 4.prependTo()2.外部插入：1.after() 在元素对象的外部插入 2.insertAfter() 作用类似于 appendTo 不过插入位置是元素对象外部 3.before() 4.insertBefore()3.包裹1.wrap() 参数可以是HTML，或者已经有的对象。 2.unwrap() 和wrap()配合使用。4.替换1.replaceWith() 2.replaceAll() 两个实际一样，主从关系不同。5.清空- empty() innerHTML=&quot;&quot;;还有一个空占位符,而empty()将内部清空,直接为null。6.移除1.remove(); 如： $(&quot;p&quot;).remove(); 去除p标签 $(&quot;p&quot;).remove(&quot;.hello&quot;); 把带hello类的p标签去除 2.detach(); 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。7.clone();jQuery操作事件:1.bind(“事件名”,fn)注意： 与js不同的是：js通过覆盖onclick属性动态操作事件,因为覆盖了之前的,所以只能动态地为其他元素的一个监听事件添加一个函数; 而jQuery是追加地,可以动态地为其他元素的一个监听事件添加多个个函数;2.unBind(“事件名”)1.只能解绑用bind绑定的事件 2.解绑了这个事件，也就解绑了这个事件监听的所有函数。 注意:jQuery3.0中弃用了bind和unBind，用on()和off()替代。3.one()1.添加一次性事件，执行事件被触发后即失效。 2.可以给事件添加多个一次性函数。 3.可以用unBind()解绑。4.页面载入事件：$(document).ready(fn); 简写:$(fn); 与window.onload=fn不同的是：jQuery页面载入事件不会覆盖，而js页面载入事件后面的会覆盖之前的。jQuery动画效果就是HTML元素的隐藏和显示。show()- show(1000); 1s后显示 - show(1000,fn); 1s后显示并且执行某个函数hide()同show()toggle()- toggle() 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。slideDown(),slideUp(),slideToggle()- slideDown() slideDown(1000) 1s内向下滑动显示出来 - slideToggle()fadeIn(),fadeOut(),fadeToggle()淡入淡出效果。animate()- 自定义的动画效果。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"jQuery的封装原理","slug":"jQuery的封装原理","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-18T17:11:54.558Z","comments":true,"path":"2019/07/19/jQuery的封装原理/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的封装原理/","excerpt":"","text":"jQuery的封装原理1.为什么要用”闭包”？ 1.内部声明和外部声明重名问题，因为变量被覆盖，导致函数失效。 2.可以使用对象对函数进行封装，但是对象如果被覆盖，则被封装的所有函数失效。 123456var obj = &#123;&#125;;obj.test = function()&#123; alert(&quot;外部test&quot;);&#125;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 3.使用工厂模式，将代码进行封装，但是还是可能被覆盖。 1234567891011121314//工厂模式function factory()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125;&lt;script type=&quot;text/javascript&quot;&gt; var obj = factory();&lt;/script&gt;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 4.问题根源在于名字，那么去掉名字就好了，但是没有名字的函数应该怎么调用？ 1234567function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125; 5.使用匿名自调用，但是只能用一次,并且无法获取数据。 123456789//匿名自调用(function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; alert(&quot;匿名自调用&quot;); return obj;&#125;)() 6.使用闭包。","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"超链接标签调用js函数","slug":"超链接标签调用js函数","date":"2019-07-18T14:25:45.056Z","updated":"2019-07-18T14:36:05.876Z","comments":true,"path":"2019/07/18/超链接标签调用js函数/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/超链接标签调用js函数/","excerpt":"","text":"超链接标签调用js函数 1.&lt;a href =&quot;#&quot; onclick =&quot;js_method()&quot;&gt;这个方法中的#号代表top，所以点击之后会跳转到页面最顶端2.&lt;a href = &quot;javascript:void(0);&quot; onclick =&quot;js_method()&quot;&gt;文本&lt;/a&gt;这是最常用的方法。前面的void（0）返回undefined，地址不会发生跳转，后面的onClick负责执行js函数。这样写还有一个好处是不会吧js方法暴露在浏览器的状态栏","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"},{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/tags/知识/"}]},{"title":"js操作表格及表格小案例","slug":"js操作表格及表格小案例","date":"2019-07-18T12:11:20.000Z","updated":"2019-07-18T14:35:18.020Z","comments":true,"path":"2019/07/18/js操作表格及表格小案例/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/js操作表格及表格小案例/","excerpt":"","text":"1.回顾表格1.HTML表格 a &lt;table border=&quot;1px&quot;&gt; 整个表格,表格加边框，这里是每个单元格td加边框。 b &lt;tr&gt; 表格中的行 c &lt;td&gt; 单元格 d table&gt;tr*3&gt;td*3 : 3行3列表格2.js操作表格1.大致套路1.获取表格对象 2.由于需要动态的操作这里使用间接方式获取tr对象。 例如：在一个单元格td中有一个checkbox按钮，通过var chk = getElementById()获取该按钮对象， 那么chk.parentNode就是单元格td对象，chk.parentNode.parentNode就是行tr对象。 3.通过表格对象.deleteRow(行号);表格对象.insertRow(行号);来进行增加，删除表格的行。 注意： 1.这里的行号从0开始。 2.不同于其他 父节点.removechild(子节点对象) 父节点.appendChild(子节点对象); 4.其他还是通过js操作表格的属性进行相应操作。 如：ta.rows[i].style.backgroundColor=&quot;red&quot;;动态改变表格颜色。2.小知识点1.行对象.rowIndex 获得该行的行号; 2.可以通过getElementByName()获取所有的行对象，对行对象数组遍历，并进行操作。 3.添加行功能时，表格对象.insertRow(行号) 返回新添加的行对象;只是添加了一个空行， 需要,行对象.insertCell();进行单元格添加。 4.表格对象.rows.length 表格总行数3.问题1.删除功能 问题：1.同时选中两个删除不能全部删除。2.全选删除时首行被删除，解决：循环初始值i设为1，忽略首行。 原因：每删除一行后，行对象数组长度同时-1。 例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3）那么i此时为2，而行号2此时没有被选择因此不能通过判断。 解决：每次删除后 判断框内 i-- 担心问题：同时删除行号1和3会不会失败？ 不会，因为1删除后，2不会进入判断，不会进行i--。 2.修改数量功能 问题：多次点击后，出现bug。 原因：多次点击，由于字符串拼接，新的innerHTML被拼接进input标签text的value属性中。 解决：进行判断，利用isNaN()判断是否为数字，是数字再进行拼接。3.具体源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;html&gt; &lt;head&gt; &lt;title&gt;js操作表格&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;!-- 总结： 1.获取tr对象 通过删除按钮地父节点.父节点; 2.表格删除行操作 ：表格对象.deleteRow(行号); 3.行对象.rowIndex 获得该行的行号; --&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; text-align: center; &#125; /*表格居中*/ #ta01&#123; margin: auto; margin-top: 80px; &#125; #ta01 tr&#123; height: 60px; text-align: center; &#125; #tr01&#123; font-size: 24px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //删除功能 function deleRow(btn)&#123; //获取table对象 var ta = document.getElementById(&quot;ta01&quot;); //获取tr对象 var tr = btn.parentNode.parentNode; //获取tr对象 通过删除按钮地父节点.父节点 //删除 ta.deleteRow(tr.rowIndex); //表格删除行操作 表格对象.deleteRow(行号); &#125; //修改功能 function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125; &#125; //保存修稿功能 function updataBlur(inp)&#123; //获取td对象 var cell = inp.parentNode; cell.innerHTML = inp.value; &#125; //------------------------------------------------------- //使用checkbox删除，功能可多选删除 function deleMore()&#123; //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.获取tr对象，通过 表格对象.deletRow() var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; //从1开始，避免首列被删除 //删除被选择的对应行号 if(chks[i].checked)&#123; //注意：这里每删除一行后，chks长度同时-1，例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3） //那么i此时为2，而行号2此时没有被选择因此不能通过判断。 //解决：每次删除后 i-- //担心问题：同时删除行号1和3会不会失败？ 不会因为1删除后，2不会进入判断，不会进行i--。 ta.deleteRow(i); i--; &#125; &#125; &#125; //完成添加功能 function addRow()&#123; //表格对象.insertRow() 行号 //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.添加行 返回添加的行对象 var row = ta.insertRow(1); //3.添加单元格 返回添加的单元格对象 //4.添加单元格内容 注意单引号 var cell00 = row.insertCell(); cell00.innerHTML=&quot;&lt;input type=&apos;checkbox&apos; name=&apos;chk&apos; id=&apos;chk&apos;/&gt;&quot;; var cell01 = row.insertCell(); cell01.innerHTML=document.getElementById(&quot;yxname&quot;).value; var cell02 = row.insertCell(); cell02.innerHTML=document.getElementById(&quot;yxprice&quot;).value; var cell03 = row.insertCell(); cell03.innerHTML=document.getElementById(&quot;yxcount&quot;).value; var cell04 = row.insertCell(); cell04.innerHTML=&quot;&lt;input type=&apos;button&apos; value=&apos;修改数量&apos; onclick=&apos;updataRow()&apos;/&gt;&lt;input type=&apos;button&apos; value=&apos;删除&apos; onclick=&apos;deleRow(this)&apos;/&gt;&quot;; &#125; //复制功能 再最后一行显示复制的 function copyRow()&#123; //添加新的行到最后一行 var ta = document.getElementById(&quot;ta01&quot;); var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; if(chks[i].checked)&#123; var copy = ta.insertRow(ta.rows.length); //ta.rows.length表格总行数 copy.innerHTML = ta.rows[i].innerHTML; //这里不需要i--，因为总长度只会增不会减少而发生错误。 &#125; &#125; &#125; //全选功能 function chooseAll()&#123; //所有的多选框同时选择，或同时取消，更改属性checked为true //获取所有的checkbox var chks = document.getElementsByName(&quot;chk&quot;); //获取全选按钮对象 var all = document.getElementById(&quot;chkk&quot;); if(all.checked)&#123; //遍历所有的checkbox for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=true; &#125; &#125;else&#123; for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=false; &#125; &#125; &#125; //隔行变色功能 function changeColor()&#123; var ta = document.getElementById(&quot;ta01&quot;); //获取所有行 var chks = document.getElementsByName(&quot;chk&quot;); //遍历 for(var i=1;i&lt;chks.length;i++)&#123; if(i%2==0)&#123; ta.rows[i].style.backgroundColor=&quot;cornflowerblue&quot;; &#125;else&#123; ta.rows[i].style.backgroundColor=&quot;green&quot;; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;游戏购买清单&lt;/h3&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleMore()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;addRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;复制&quot; onclick=&quot;copyRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;隔行变色&quot; onclick=&quot;changeColor()&quot;/&gt; &lt;hr /&gt; &lt;table id=&quot;ta01&quot; border=&quot;1px&quot;&gt; &lt;tr id=&quot;tr01&quot;&gt; &lt;td width=&quot;50px&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chkk&quot; value=&quot;0&quot; onclick=&quot;chooseAll()&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;名称&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;价格&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;数量&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;1&quot; /&gt;&lt;/td&gt; &lt;td&gt;绝地求生&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;td id=&quot;cell&quot;&gt;2&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;2&quot; /&gt;&lt;/td&gt; &lt;td&gt;守望先锋&lt;/td&gt; &lt;td&gt;299&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;3&quot; /&gt;&lt;/td&gt; &lt;td&gt;死神&lt;/td&gt; &lt;td&gt;88&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr /&gt; &lt;b&gt;请输入需要添加的游戏信息：&lt;/b&gt;&lt;br /&gt; 游戏名：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxname&quot; value=&quot;&quot; /&gt; 价格：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxprice&quot; value=&quot;&quot; /&gt; 数量：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxcount&quot; value=&quot;&quot; /&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"}]},{"title":"MarkDown使用学习","slug":"MarkDown使用学习","date":"2019-07-18T01:22:11.000Z","updated":"2019-07-18T14:34:15.117Z","comments":true,"path":"2019/07/18/MarkDown使用学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/MarkDown使用学习/","excerpt":"","text":"一级标题hello hexo 这是三级标题 列表1a 子列表1 斜体哦 粗体哦 又粗又斜了b 子列表2 这里是引用的 &lt; c 子列表3 这是超链接 列表2public static void main(Sring[] args) 123456789function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125; 这里是源码1234567891011121314151617181920212223242526272829 ---title: MarkDown使用学习---# 一级标题## hello hexo![吉冈里帆](http://b-ssl.duitang.com/uploads/item/201712/27/20171227143148_envyt.jpeg)### 这是三级标题- 列表1 a 子列表1 *斜体哦* **粗体哦** ***又粗又斜了*** b 子列表2 &gt; 这里是引用的 &lt; --- c 子列表3 [这是超链接](https://www.baidu.com/)- 列表2 `public static void main(Sring[] args)`function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://Zhangbingwu.github.io/tags/MarkDown/"}]}]}