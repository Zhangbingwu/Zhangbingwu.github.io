{"meta":{"title":"却又像风","subtitle":null,"description":null,"author":"却又像风","url":"https://Zhangbingwu.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-07-18T07:04:21.000Z","updated":"2019-07-18T07:05:53.842Z","comments":true,"path":"categories/index.html","permalink":"https://Zhangbingwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-18T07:03:31.000Z","updated":"2019-07-18T07:04:01.872Z","comments":true,"path":"tags/index.html","permalink":"https://Zhangbingwu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Servlet入门","date":"2019-07-20T09:52:11.209Z","updated":"2019-07-21T07:09:51.353Z","comments":true,"path":"2019/07/20/Servlet入门/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Servlet入门/","excerpt":"","text":"服务器什么是服务器？ 可以实时地调用不同的代码的一个容器。 Servlet技术Servlet概念 Server AppletServlet（Server Applet）：全称Java Servlet。是基于Java技术的web组件，由容器管理并产生动态内容。Servlet引擎作为WEB服务器的扩展提供支持Servlet功能。Servlet与客户端通过Servlet容器实现的请求/响应模式进行交互。动态web开发技术。 为什么有Servlet技术？ 服务器接收到浏览器请求后,自动调用对应逻辑代码进行请求处理,但是逻辑代码是有程序员编写并放到服务器中,那么服务器怎么知道该怎么调用？调用哪个类？哪个方法进行请求处理？ 程序员在编写代码的时候能够按照服务器能够识别的规则进行编写,浏览器按照指定的规则进行发送请求,那么服务器就可以调用并执行相应逻辑的代码进行请求处理。 狭义的Servlet是指Java实现的一个接口 通过实现这个接口从而规范代码书写。 广义的Servlet是指任何实现了这个接口的类 一般人们理解为广义的。 使用IDEA配置和使用Tomcat IDEA配置和使用Tomcat 步骤 1.类需要继承HttpServlet其父类实现了Servlet接口,保证了规范。 2.重写方法 3.方法中书写逻辑代码 4.在webRoot下的WEB-INF文件夹下的web.xnml文件中配置servlet 组成如http://localhost:8080/project/test服务器地址:端口/虚拟项目名/Servlet别名 Servlet生命周期具体过程1.启动web服务器解析web.xml 2.第一次接收到客户端请求,服务器判断Servlet实例是否存在，加载Servlet并创建实例 3.init()并调用请求相应方法 4.等待其他请求 5.服务器关闭,Servlet销毁,destroy()1.从第一次接收到请求,到服务器关闭2.如果web.xml配置了load-on-startup,生命周期从服务器启动,到服务器关闭。service()和doGet()和doPost()service()可以处理get/post方式的请求,如果servlet中有service方法,会优先调用service方法对请求进行处理。doGet()处理get方式的请求doPost()处理post方式的请求注意*如果在重写的service方法中调用了父类的service方法(super.service(req, resp);),则service方法处理完后,会再次根据请求方式相应的doGet和doPost方法。所以,一般情况下,我们是不在重写的service中调用父类的service方法的,避免出现405错误(请求方式不匹配)*Servlet常见错误404错误：资源未找到 请求地址中虚拟项目名以及Servlet别名检查是否与web.xml匹配。 500错误：内部服务器错误 ClassNotFoundException:com.xxx.xxx检查web.xml中Servlet类的全限定路径是否错误servlet-class service方法体代码逻辑错误。 405错误：请求方式不支持 检查get和post请求方式是否有匹配的doGet和doPost 一般使用service方法且不要调用父类 Request对象什么是Request对象？服务器接受到请求后,需要存储请求,并保证请求数据的完整性,因此创建一个对象来保存,在service方法执行时作为实参传递到service方法中。获取请求数据 获取请求头数据 req.getMethod() //获取请求方式 req.getRequestURL() //获取请求URL req.getRequestURI() //获取请求URI URI就是具体的资源路径 req.getScheme() //获取请求协议信息 获取请求行数据 req.getHeader(“键名”) //获取指定的附加信息 req.getHeaderNames() //获取所有的附加信息的键名 返回枚举类型12345678Enumeration&lt;String&gt; names = req.getHeaderNames(); //返回枚举类型 //遍历枚举 while(names.hasMoreElements())&#123; String name = names.nextElement(); //根据键名查询值 String value = req.getHeader(name); System.out.println(name+value); &#125; 获取请求主体 req.getParameter(“键名”) //获取指定的用户数据 req.getParameterValues(“键名”) //获取同名不同值的用户数据 返回数组 req.getParameterNames() //获取所有的用户数据的键名 返回枚举类型 Response对象作用对请求做出响应设置响应数据 设置响应头 resp.setHeader(String name,String name); //会覆盖掉原来的 resp.addHeader(String name,String name); //会继续添加 设置响应编码格式resp.setHeader(“content-type”,”text/html;charset=utf-8”);resp.setContentType(“text/html;charset=utf-8”); 设置响应状态resp.sendError(int num,String msg); 设置响应实体esp.getWriter().write(String content); 总结 service请求处理代码流程 设置响应编码格式 获取请求数据 处理请求数据 数据库操作（MVC思想） 响应处理结果","categories":[],"tags":[]},{"title":"Http协议学习","slug":"Http协议学习","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-20T07:13:56.577Z","comments":true,"path":"2019/07/20/Http协议学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/20/Http协议学习/","excerpt":"","text":"了解Http什么是Http？ 全称Hyper Text Transfer Protocol（超文本传输协议） 作用1.用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。2.是对服务器和客户端交流的格式规范。3.没有http协议也可以达到交流的目的,但是影响推广。 Http工作原理 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 https://www.jianshu.com/p/9f3e879a4c9c HTTP默认端口号为80 HTTP特点 简单快速发送请求时，只需要传送请求方法和路径。请求方法常用的有：GET,POST,HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单,使得HTTP服务器的程序规模很小,因而通信速度块。 媒体独立服务器可以接受客户端发送的任何类型的数据,并用content-type对正文内容类型加以标记。 无连接无连接的含义是限制每次连接只处理一个请求。客户端请求,服务器处理并相应,收到客户端应答后连接断开。这种方式可以节省传输时间。注意:HTTP 1.1 后支持持续连接。 无状态服务器每次接受到请求后,处理响应,但是不会记忆请求信息,如果需要第二次请求,即使内容相同也要重新发送请求信息,这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。联想填寄快递单。 HTTP交互流程 客户端与服务器建立连接。 客户端向服务端发送请求。 服务端接受处理请求,做出响应。 关闭客户端与服务器的连接。(HTTP1.1之后不会立即关闭) HTTP消息结构请求消息请求头:请求方式 URL 协议版本。 请求行:消息报头,一般用来说明客户端需要使用的一些附加信息。 空行:必须要有。 请求主体响应消息状态行:协议版本,状态码,状态描述。 响应头:消息报头,客户端使用的附加信息,时间,conten-type,content-length。 空行:必须要有 响应正文不同的请求方式,消息结构会有一些差异。 GET方式没有请求主体,直接以？隔开拼接在请求地址后。 HTTP请求方式GET请求方式 特点 get方式只能传输少量数据,不是因为http协议,而是因为地址栏长度有限制。 没有请求主体,直接以？隔开拼接在请求地址后。 不安全,因为请求信息暴露。 效率高。 POST请求方式 特点 POST方式可以传输大量数据。 请求信息可以都放在请求主体中,也可以拼接在请求地址后,可以合在一起用。 安全。 效率相比GET低。 不同请求方式使用 第一衡量指标：安全 然后考虑数据量。 状态码状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用HTTP状态码共分为5种类型： 1** 信息 2** 成功 3** 重定向 4** 客户端错误 5** 服务器错误 常见状态码 200 OK //客户端请求成功 400 BadRequest //客户端请求有语法错误 401 Unauthorized //请求未经授权 403 Forbidden //服务器拒绝提供服务 404 Not Found //请求资源不存在 500 Internal Server Error //服务器发生了不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端请求,一段时间后会恢复","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://Zhangbingwu.github.io/tags/Http/"}]},{"title":"jQuery的封装原理","slug":"jQuery的封装原理","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-18T17:11:54.558Z","comments":true,"path":"2019/07/19/jQuery的封装原理/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的封装原理/","excerpt":"","text":"jQuery的封装原理1.为什么要用”闭包”？ 1.内部声明和外部声明重名问题，因为变量被覆盖，导致函数失效。 2.可以使用对象对函数进行封装，但是对象如果被覆盖，则被封装的所有函数失效。 123456var obj = &#123;&#125;;obj.test = function()&#123; alert(&quot;外部test&quot;);&#125;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 3.使用工厂模式，将代码进行封装，但是还是可能被覆盖。 1234567891011121314//工厂模式function factory()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125;&lt;script type=&quot;text/javascript&quot;&gt; var obj = factory();&lt;/script&gt;&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;测试&quot; onclick=&quot;obj.test()&quot;/&gt; 4.问题根源在于名字，那么去掉名字就好了，但是没有名字的函数应该怎么调用？ 1234567function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; return obj;&#125; 5.使用匿名自调用，但是只能用一次,并且无法获取数据。 123456789//匿名自调用(function()&#123; var obj = &#123;&#125;; obj.test = function()&#123; alert(&quot;外部test&quot;); &#125; alert(&quot;匿名自调用&quot;); return obj;&#125;)() 6.使用闭包。","categories":[{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/categories/知识/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"jQuery的学习","slug":"jQuery的学习","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-19T16:48:27.668Z","comments":true,"path":"2019/07/19/jQuery的学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/19/jQuery的学习/","excerpt":"","text":"jQuery的选择器学习 1.基本选择器- 1.id $(&quot;#id&quot;); - 2.标签名 $(&quot;标签名&quot;); - 3.类 $(&quot;.类名&quot;); 如:$(&quot;.common&quot;); - 4.全部 $(&quot;*&quot;); - 5.组合 如：$(&quot;id,标签名,····&quot;); -注意：jQuery选择器返回的是装有元素对象的数组。id选择器是装有一个对象的数组。2.层级选择器1.ancestor descendant 祖先 后代 $(&quot;祖先 后代 &quot;) 2.parent &gt; child :在给定的父元素下匹配所有的子元素 $(&quot;form &gt; input&quot;) 注意：只有子元素，孙子元素不能。 3.prev + next :匹配所有紧接在 prev 元素后的 next 元素 $(&quot;label + input&quot;)注意：这里是紧接的，也就是下一个！ 4.prev ~ siblings :匹配 prev 元素之后的所有 siblings 元素 $(&quot;form ~ input&quot;) 注意：找到所有与表单同辈的 input 元素3.简单选择器对获得的对象数组进一步过滤，从而得到需要的对象。 如：&apos;$(&quot;li:first&quot;);&apos;所有li标签对象数组中的第一个。 &apos;$(&quot;li:not([class])&quot;);&apos;所有li标签对象数组中不包含class属性的 :even,:odd 索引的奇偶判断 :eq(index);索引为index的对象 :gt(index);索引为index以后的对象 :it(index);索引为index以前的对象 :header; h1,h2,h3之类的标题元素4.属性选择器$(&quot;input[id=&apos;1&apos;]&quot;); != 不为某些值;^= :以某些值开头;$= ：以某些值结尾;*= ：包含某些值 多个合一块用：$(&quot;input[id],name=&apos;zs&apos;&quot;);5.表单选择器:表单元素 选择该类表单元素的对象数组。6.内容选择器$(&quot;b:contains(&apos;你好&apos;)&quot;);b标签中的值是‘你好’的b标签元素对象数组。 $(&quot;div:has(p)&quot;);所有包含p标签的div标签元素对象数组。7.可见性选择器:visible 可见的标签 :hidden 不可见的标签jQuery操作元素属性:1.获取属性对象数组.attr(&quot;&quot;); 注意：对象数组.attr(&quot;value&quot;);只能获得默认的值，不能动态更新， 类似自定义属性的getAttribute();可以使用 对象数组.val();2.修改属性对象数组.attr(&quot;类型&quot;,&quot;新值&quot;);jQuery操作元素内容1.获取元素内容对象数组.html(); 对象数组.text(); 两者的区别同innerHTML和innerText一样。2.修改元素内容对象数组.html(&quot;新内容&quot;); 对象数组.text(&quot;新内容&quot;); 两个都会覆盖原有内容。jQuery操作元素样式:1.对象数组.css();- 对象数组.css(&quot;width&quot;); 获取width值 - 对象数组.css(&quot;属性名&quot;,&quot;属性值&quot;); - json方式 对象数组.css({&quot;&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;,···}); 不同样式之间逗号隔开 如：`div02.css({&quot;height&quot;:&quot;300px&quot;,&quot;width&quot;:&quot;300px&quot;,&quot;border&quot;:&quot;solid 1px black&quot;});`2.对象数组.addClass(“类名”);- 对象数组.addClass(&quot;类名1 类名2&quot;); 不同类之间 空格隔开#jQuery操作文档结构: 1.内部插入：1.append() 追加 2.appendTo() 将元素对象追加到指定的元素对象中，并删除该元素对象。 3.prepend() 追加到之前 4.prependTo()2.外部插入：1.after() 在元素对象的外部插入 2.insertAfter() 作用类似于 appendTo 不过插入位置是元素对象外部 3.before() 4.insertBefore()3.包裹1.wrap() 参数可以是HTML，或者已经有的对象。 2.unwrap() 和wrap()配合使用。4.替换1.replaceWith() 2.replaceAll() 两个实际一样，主从关系不同。5.清空- empty() innerHTML=&quot;&quot;;还有一个空占位符,而empty()将内部清空,直接为null。6.移除1.remove(); 如： $(&quot;p&quot;).remove(); 去除p标签 $(&quot;p&quot;).remove(&quot;.hello&quot;); 把带hello类的p标签去除 2.detach(); 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。7.clone();jQuery操作事件:1.bind(“事件名”,fn)注意： 与js不同的是：js通过覆盖onclick属性动态操作事件,因为覆盖了之前的,所以只能动态地为其他元素的一个监听事件添加一个函数; 而jQuery是追加地,可以动态地为其他元素的一个监听事件添加多个个函数;2.unBind(“事件名”)1.只能解绑用bind绑定的事件 2.解绑了这个事件，也就解绑了这个事件监听的所有函数。 注意:jQuery3.0中弃用了bind和unBind，用on()和off()替代。3.one()1.添加一次性事件，执行事件被触发后即失效。 2.可以给事件添加多个一次性函数。 3.可以用unBind()解绑。4.页面载入事件：$(document).ready(fn); 简写:$(fn); 与window.onload=fn不同的是：jQuery页面载入事件不会覆盖，而js页面载入事件后面的会覆盖之前的。jQuery动画效果就是HTML元素的隐藏和显示。show()- show(1000); 1s后显示 - show(1000,fn); 1s后显示并且执行某个函数hide()同show()toggle()- toggle() 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。slideDown(),slideUp(),slideToggle()- slideDown() slideDown(1000) 1s内向下滑动显示出来 - slideToggle()fadeIn(),fadeOut(),fadeToggle()淡入淡出效果。animate()- 自定义的动画效果。","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://Zhangbingwu.github.io/tags/jQuery/"}]},{"title":"超链接标签调用js函数","slug":"超链接标签调用js函数","date":"2019-07-18T14:25:45.056Z","updated":"2019-07-18T14:36:05.876Z","comments":true,"path":"2019/07/18/超链接标签调用js函数/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/超链接标签调用js函数/","excerpt":"","text":"超链接标签调用js函数 1.&lt;a href =&quot;#&quot; onclick =&quot;js_method()&quot;&gt;这个方法中的#号代表top，所以点击之后会跳转到页面最顶端2.&lt;a href = &quot;javascript:void(0);&quot; onclick =&quot;js_method()&quot;&gt;文本&lt;/a&gt;这是最常用的方法。前面的void（0）返回undefined，地址不会发生跳转，后面的onClick负责执行js函数。这样写还有一个好处是不会吧js方法暴露在浏览器的状态栏","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"},{"name":"知识","slug":"知识","permalink":"https://Zhangbingwu.github.io/tags/知识/"}]},{"title":"js操作表格及表格小案例","slug":"js操作表格及表格小案例","date":"2019-07-18T12:11:20.000Z","updated":"2019-07-18T14:35:18.020Z","comments":true,"path":"2019/07/18/js操作表格及表格小案例/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/js操作表格及表格小案例/","excerpt":"","text":"1.回顾表格1.HTML表格 a &lt;table border=&quot;1px&quot;&gt; 整个表格,表格加边框，这里是每个单元格td加边框。 b &lt;tr&gt; 表格中的行 c &lt;td&gt; 单元格 d table&gt;tr*3&gt;td*3 : 3行3列表格2.js操作表格1.大致套路1.获取表格对象 2.由于需要动态的操作这里使用间接方式获取tr对象。 例如：在一个单元格td中有一个checkbox按钮，通过var chk = getElementById()获取该按钮对象， 那么chk.parentNode就是单元格td对象，chk.parentNode.parentNode就是行tr对象。 3.通过表格对象.deleteRow(行号);表格对象.insertRow(行号);来进行增加，删除表格的行。 注意： 1.这里的行号从0开始。 2.不同于其他 父节点.removechild(子节点对象) 父节点.appendChild(子节点对象); 4.其他还是通过js操作表格的属性进行相应操作。 如：ta.rows[i].style.backgroundColor=&quot;red&quot;;动态改变表格颜色。2.小知识点1.行对象.rowIndex 获得该行的行号; 2.可以通过getElementByName()获取所有的行对象，对行对象数组遍历，并进行操作。 3.添加行功能时，表格对象.insertRow(行号) 返回新添加的行对象;只是添加了一个空行， 需要,行对象.insertCell();进行单元格添加。 4.表格对象.rows.length 表格总行数3.问题1.删除功能 问题：1.同时选中两个删除不能全部删除。2.全选删除时首行被删除，解决：循环初始值i设为1，忽略首行。 原因：每删除一行后，行对象数组长度同时-1。 例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3）那么i此时为2，而行号2此时没有被选择因此不能通过判断。 解决：每次删除后 判断框内 i-- 担心问题：同时删除行号1和3会不会失败？ 不会，因为1删除后，2不会进入判断，不会进行i--。 2.修改数量功能 问题：多次点击后，出现bug。 原因：多次点击，由于字符串拼接，新的innerHTML被拼接进input标签text的value属性中。 解决：进行判断，利用isNaN()判断是否为数字，是数字再进行拼接。3.具体源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;html&gt; &lt;head&gt; &lt;title&gt;js操作表格&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;!-- 总结： 1.获取tr对象 通过删除按钮地父节点.父节点; 2.表格删除行操作 ：表格对象.deleteRow(行号); 3.行对象.rowIndex 获得该行的行号; --&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; text-align: center; &#125; /*表格居中*/ #ta01&#123; margin: auto; margin-top: 80px; &#125; #ta01 tr&#123; height: 60px; text-align: center; &#125; #tr01&#123; font-size: 24px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //删除功能 function deleRow(btn)&#123; //获取table对象 var ta = document.getElementById(&quot;ta01&quot;); //获取tr对象 var tr = btn.parentNode.parentNode; //获取tr对象 通过删除按钮地父节点.父节点 //删除 ta.deleteRow(tr.rowIndex); //表格删除行操作 表格对象.deleteRow(行号); &#125; //修改功能 function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125; &#125; //保存修稿功能 function updataBlur(inp)&#123; //获取td对象 var cell = inp.parentNode; cell.innerHTML = inp.value; &#125; //------------------------------------------------------- //使用checkbox删除，功能可多选删除 function deleMore()&#123; //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.获取tr对象，通过 表格对象.deletRow() var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; //从1开始，避免首列被删除 //删除被选择的对应行号 if(chks[i].checked)&#123; //注意：这里每删除一行后，chks长度同时-1，例如：删除了行号为1的，同时要删除行号为2的，但是循环执行删除1后，行号2变为了1（可以试一下同时删除行号1和3） //那么i此时为2，而行号2此时没有被选择因此不能通过判断。 //解决：每次删除后 i-- //担心问题：同时删除行号1和3会不会失败？ 不会因为1删除后，2不会进入判断，不会进行i--。 ta.deleteRow(i); i--; &#125; &#125; &#125; //完成添加功能 function addRow()&#123; //表格对象.insertRow() 行号 //1.获取表格对象 var ta = document.getElementById(&quot;ta01&quot;); //2.添加行 返回添加的行对象 var row = ta.insertRow(1); //3.添加单元格 返回添加的单元格对象 //4.添加单元格内容 注意单引号 var cell00 = row.insertCell(); cell00.innerHTML=&quot;&lt;input type=&apos;checkbox&apos; name=&apos;chk&apos; id=&apos;chk&apos;/&gt;&quot;; var cell01 = row.insertCell(); cell01.innerHTML=document.getElementById(&quot;yxname&quot;).value; var cell02 = row.insertCell(); cell02.innerHTML=document.getElementById(&quot;yxprice&quot;).value; var cell03 = row.insertCell(); cell03.innerHTML=document.getElementById(&quot;yxcount&quot;).value; var cell04 = row.insertCell(); cell04.innerHTML=&quot;&lt;input type=&apos;button&apos; value=&apos;修改数量&apos; onclick=&apos;updataRow()&apos;/&gt;&lt;input type=&apos;button&apos; value=&apos;删除&apos; onclick=&apos;deleRow(this)&apos;/&gt;&quot;; &#125; //复制功能 再最后一行显示复制的 function copyRow()&#123; //添加新的行到最后一行 var ta = document.getElementById(&quot;ta01&quot;); var chks = document.getElementsByName(&quot;chk&quot;); //获取到了所有的行 //遍历每一行 for(var i=1;i&lt;chks.length;i++)&#123; if(chks[i].checked)&#123; var copy = ta.insertRow(ta.rows.length); //ta.rows.length表格总行数 copy.innerHTML = ta.rows[i].innerHTML; //这里不需要i--，因为总长度只会增不会减少而发生错误。 &#125; &#125; &#125; //全选功能 function chooseAll()&#123; //所有的多选框同时选择，或同时取消，更改属性checked为true //获取所有的checkbox var chks = document.getElementsByName(&quot;chk&quot;); //获取全选按钮对象 var all = document.getElementById(&quot;chkk&quot;); if(all.checked)&#123; //遍历所有的checkbox for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=true; &#125; &#125;else&#123; for(var i=1;i&lt;chks.length;i++)&#123; chks[i].checked=false; &#125; &#125; &#125; //隔行变色功能 function changeColor()&#123; var ta = document.getElementById(&quot;ta01&quot;); //获取所有行 var chks = document.getElementsByName(&quot;chk&quot;); //遍历 for(var i=1;i&lt;chks.length;i++)&#123; if(i%2==0)&#123; ta.rows[i].style.backgroundColor=&quot;cornflowerblue&quot;; &#125;else&#123; ta.rows[i].style.backgroundColor=&quot;green&quot;; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;游戏购买清单&lt;/h3&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleMore()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;添加&quot; onclick=&quot;addRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;复制&quot; onclick=&quot;copyRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;隔行变色&quot; onclick=&quot;changeColor()&quot;/&gt; &lt;hr /&gt; &lt;table id=&quot;ta01&quot; border=&quot;1px&quot;&gt; &lt;tr id=&quot;tr01&quot;&gt; &lt;td width=&quot;50px&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chkk&quot; value=&quot;0&quot; onclick=&quot;chooseAll()&quot;/&gt;&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;名称&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;价格&lt;/td&gt; &lt;td width=&quot;100px&quot;&gt;数量&lt;/td&gt; &lt;td width=&quot;200px&quot;&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;1&quot; /&gt;&lt;/td&gt; &lt;td&gt;绝地求生&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;td id=&quot;cell&quot;&gt;2&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;2&quot; /&gt;&lt;/td&gt; &lt;td&gt;守望先锋&lt;/td&gt; &lt;td&gt;299&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;chk&quot; id=&quot;chk&quot; value=&quot;3&quot; /&gt;&lt;/td&gt; &lt;td&gt;死神&lt;/td&gt; &lt;td&gt;88&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;修改数量&quot; onclick=&quot;updataRow()&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;删除&quot; onclick=&quot;deleRow(this)&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr /&gt; &lt;b&gt;请输入需要添加的游戏信息：&lt;/b&gt;&lt;br /&gt; 游戏名：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxname&quot; value=&quot;&quot; /&gt; 价格：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxprice&quot; value=&quot;&quot; /&gt; 数量：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;yxcount&quot; value=&quot;&quot; /&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://Zhangbingwu.github.io/tags/JS/"}]},{"title":"MarkDown使用学习","slug":"MarkDown使用学习","date":"2019-07-18T01:22:11.000Z","updated":"2019-07-18T14:34:15.117Z","comments":true,"path":"2019/07/18/MarkDown使用学习/","link":"","permalink":"https://Zhangbingwu.github.io/2019/07/18/MarkDown使用学习/","excerpt":"","text":"一级标题hello hexo 这是三级标题 列表1a 子列表1 斜体哦 粗体哦 又粗又斜了b 子列表2 这里是引用的 &lt; c 子列表3 这是超链接 列表2public static void main(Sring[] args) 123456789function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125; 这里是源码1234567891011121314151617181920212223242526272829 ---title: MarkDown使用学习---# 一级标题## hello hexo![吉冈里帆](http://b-ssl.duitang.com/uploads/item/201712/27/20171227143148_envyt.jpeg)### 这是三级标题- 列表1 a 子列表1 *斜体哦* **粗体哦** ***又粗又斜了*** b 子列表2 &gt; 这里是引用的 &lt; --- c 子列表3 [这是超链接](https://www.baidu.com/)- 列表2 `public static void main(Sring[] args)`function updataRow()&#123; //将td内容变为input //获取td对象 var cell = document.getElementById(&quot;cell&quot;); //存在bug 点两次修改 字符串拼接 需要判断cell.innerHTML是否为数字 if(!isNaN(cell.innerHTML))&#123; cell.innerHTML=&quot;&lt;input type=&apos;text&apos; value=&apos;&quot;+cell.innerHTML+&quot;&apos; onblur=&apos;updataBlur(this)&apos;/&gt;&quot;; &#125;&#125;","categories":[{"name":"教学","slug":"教学","permalink":"https://Zhangbingwu.github.io/categories/教学/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://Zhangbingwu.github.io/tags/MarkDown/"}]}]}